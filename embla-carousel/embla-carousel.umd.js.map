{"version":3,"file":"embla-carousel.umd.js","sources":["src/vanilla/components/alignment.ts","src/vanilla/components/counter.ts","src/vanilla/components/vector1d.ts","src/vanilla/components/direction.ts","src/vanilla/components/eventStore.ts","src/vanilla/components/limit.ts","src/vanilla/components/dragHandler.ts","src/vanilla/components/dragTracker.ts","src/vanilla/components/utils.ts","src/vanilla/components/scrollBody.ts","src/vanilla/components/scrollBounds.ts","src/vanilla/components/scrollContain.ts","src/vanilla/components/scrollLooper.ts","src/vanilla/components/scrollTarget.ts","src/vanilla/components/slideLooper.ts","src/vanilla/components/slidesInView.ts","src/vanilla/components/translate.ts","src/vanilla/components/engine.ts","src/vanilla/components/pxToPercent.ts","src/vanilla/components/scrollProgress.ts","src/vanilla/components/axis.ts","src/vanilla/components/scrollSnap.ts","src/vanilla/components/scrollLimit.ts","src/vanilla/components/animation.ts","src/vanilla/components/scrollTo.ts","src/vanilla/components/options.ts","src/vanilla/index.ts","src/vanilla/components/eventEmitter.ts"],"sourcesContent":["export type AlignmentOption = 'start' | 'center' | 'end' | number\n\ntype Params = {\n  viewSize: number\n  align: AlignmentOption\n}\n\nexport type Alignment = {\n  measure: (n: number) => number\n}\n\nexport function Alignment(params: Params): Alignment {\n  const { viewSize, align } = params\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return (viewSize - n) / 2\n  }\n\n  function end(n: number): number {\n    return viewSize - n\n  }\n\n  function percent(): number {\n    return viewSize * Number(align)\n  }\n\n  function measure(n: number): number {\n    if (typeof align === 'number') return percent()\n    return predefined[align](n)\n  }\n\n  const self: Alignment = {\n    measure,\n  }\n  return self\n}\n","import { Limit } from './limit'\n\ntype Params = {\n  start: number\n  limit: Limit\n  loop: boolean\n}\n\nexport type Counter = {\n  min: number\n  max: number\n  get: () => number\n  set: (n: number) => Counter\n  add: (n: number) => Counter\n  clone: () => Counter\n}\n\nexport function Counter(params: Params): Counter {\n  const { start, limit, loop } = params\n  const { min, max } = limit\n  const type = loop ? 'loop' : 'constrain'\n  const withinLimit = limit[type]\n  let counter = withinLimit(start)\n\n  function get(): number {\n    return counter\n  }\n\n  function set(n: number): Counter {\n    counter = withinLimit(n)\n    return self\n  }\n\n  function add(n: number): Counter {\n    if (n !== 0) {\n      const sign = n / Math.abs(n)\n      set(get() + sign)\n      return add(n + sign * -1)\n    }\n    return self\n  }\n\n  function clone(): Counter {\n    return Counter({ start: get(), limit, loop })\n  }\n\n  const self: Counter = {\n    add,\n    clone,\n    get,\n    max,\n    min,\n    set,\n  }\n  return self\n}\n","export type Vector1D = {\n  get: () => number\n  set: (v: Vector1D | number) => Vector1D\n  add: (v: Vector1D | number) => Vector1D\n  subtract: (v: Vector1D | number) => Vector1D\n  multiply: (n: number) => Vector1D\n  divide: (n: number) => Vector1D\n  normalize: () => Vector1D\n}\n\nexport function Vector1D(value: number): Vector1D {\n  let vector = value\n\n  function get(): number {\n    return vector\n  }\n\n  function set(n: Vector1D | number): Vector1D {\n    vector = readNumber(n)\n    return self\n  }\n\n  function add(n: Vector1D | number): Vector1D {\n    vector += readNumber(n)\n    return self\n  }\n\n  function subtract(n: Vector1D | number): Vector1D {\n    vector -= readNumber(n)\n    return self\n  }\n\n  function multiply(n: number): Vector1D {\n    vector *= n\n    return self\n  }\n\n  function divide(n: number): Vector1D {\n    vector /= n\n    return self\n  }\n\n  function normalize(): Vector1D {\n    if (vector !== 0) divide(vector)\n    return self\n  }\n\n  function readNumber(n: Vector1D | number): number {\n    return typeof n === 'number' ? n : n.get()\n  }\n\n  const self: Vector1D = {\n    add,\n    divide,\n    get,\n    multiply,\n    normalize,\n    set,\n    subtract,\n  }\n  return self\n}\n","import { Vector1D } from './vector1d'\n\nexport type Direction = {\n  get: () => number\n  set: (v: Vector1D) => Direction\n}\n\nexport function Direction(value: number): Direction {\n  const direction = Vector1D(normalize(value))\n  const { get } = direction\n\n  function normalize(n: number): number {\n    return n === 0 ? 0 : n / Math.abs(n)\n  }\n\n  function set(v: Vector1D): Direction {\n    const d = normalize(v.get())\n    if (d !== 0) direction.set(d)\n    return self\n  }\n\n  const self: Direction = {\n    get,\n    set,\n  }\n  return self\n}\n","type EventRemover = () => void\ntype EventHandler = EventListener | EventListenerObject | null\ntype EventOptions = boolean | AddEventListenerOptions | undefined\n\nexport type EventStore = {\n  add: (\n    node: EventTarget,\n    type: string,\n    handler: EventHandler,\n    options?: EventOptions,\n  ) => EventStore\n  removeAll: () => EventStore\n}\n\nexport function EventStore(): EventStore {\n  let listeners: EventRemover[] = []\n\n  function add(\n    node: EventTarget,\n    type: string,\n    handler: EventHandler,\n    options: EventOptions = false,\n  ): EventStore {\n    node.addEventListener(type, handler, options)\n    listeners.push(() => {\n      return node.removeEventListener(type, handler, options)\n    })\n    return self\n  }\n\n  function removeAll(): EventStore {\n    listeners = listeners.filter(remove => remove())\n    return self\n  }\n\n  const self: EventStore = {\n    add,\n    removeAll,\n  }\n  return self\n}\n","type Limits = 'min' | 'max' | ''\n\ntype Params = {\n  min: number\n  max: number\n}\n\nexport type Limit = {\n  min: number\n  max: number\n  length: number\n  loop: (n: number) => number\n  constrain: (n: number) => number\n  reachedAny: (n: number) => boolean\n  reachedMax: (n: number) => boolean\n  reachedMin: (n: number) => boolean\n  removeOffset: (n: number) => number\n}\n\nexport function Limit(params: Params): Limit {\n  const { min, max } = params\n  const loopLimits = { min: max, max: min }\n  const constrainLimits = { min, max }\n  const length = Math.abs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function reachedWhich(n: number): Limits {\n    if (reachedMin(n)) return 'min'\n    if (reachedMax(n)) return 'max'\n    return ''\n  }\n\n  function removeOffset(n: number): number {\n    if (min === max) return n\n    while (reachedMin(n)) n += length\n    while (reachedMax(n)) n -= length\n    return n\n  }\n\n  function loop(n: number): number {\n    const which = reachedWhich(n)\n    return which ? loopLimits[which] : n\n  }\n\n  function constrain(n: number): number {\n    const which = reachedWhich(n)\n    return which ? constrainLimits[which] : n\n  }\n\n  const self: Limit = {\n    constrain,\n    length,\n    loop,\n    max,\n    min,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset,\n  }\n  return self\n}\n","import { Animation } from './animation'\nimport { Counter } from './counter'\nimport { Direction } from './direction'\nimport { DragTracker } from './dragTracker'\nimport { EventEmitter } from './eventEmitter'\nimport { Axis } from './axis'\nimport { EventStore } from './eventStore'\nimport { Limit } from './limit'\nimport { ScrollBody } from './scrollBody'\nimport { ScrollTarget } from './scrollTarget'\nimport { ScrollTo } from './scrollTo'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  axis: Axis\n  element: HTMLElement\n  target: Vector1D\n  dragFree: boolean\n  dragTracker: DragTracker\n  location: Vector1D\n  animation: Animation\n  scrollTo: ScrollTo\n  scrollBody: ScrollBody\n  scrollTarget: ScrollTarget\n  index: Counter\n  limit: Limit\n  loop: boolean\n  events: EventEmitter\n}\n\nexport type DragHandler = {\n  addActivationEvents: () => void\n  clickAllowed: () => boolean\n  pointerDown: () => boolean\n  removeActivationEvents: EventStore['removeAll']\n  removeInteractionEvents: EventStore['removeAll']\n}\n\nexport function DragHandler(params: Params): DragHandler {\n  const { target, scrollBody, dragFree, animation, axis } = params\n  const { element, dragTracker, location, events, limit } = params\n  const { scroll: scrollAxis, cross: crossAxis } = axis\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA']\n  const startScroll = Vector1D(0)\n  const startCross = Vector1D(0)\n  const dragStartPoint = Vector1D(0)\n  const activationEvents = EventStore()\n  const interactionEvents = EventStore()\n  const removeActivationEvents = activationEvents.removeAll\n  const removeInteractionEvents = interactionEvents.removeAll\n  const snapForceBoost = { mouse: 2.5, touch: 3.5 }\n  const freeForceBoost = { mouse: 5, touch: 7 }\n  const baseSpeed = dragFree ? 5 : 12\n  const dragThreshold = 4\n  const edgeLimit = Limit({\n    min: limit.min - 70,\n    max: limit.max + 70,\n  })\n\n  let pointerIsDown = false\n  let preventScroll = false\n  let preventClick = false\n  let isMouse = false\n\n  function addActivationEvents(): void {\n    const node = element\n    activationEvents\n      .add(node, 'touchmove', () => undefined)\n      .add(node, 'touchend', () => undefined)\n      .add(node, 'touchstart', down)\n      .add(node, 'mousedown', down)\n      .add(node, 'touchcancel', up)\n      .add(node, 'contextmenu', up)\n      .add(node, 'click', click)\n  }\n\n  function addInteractionEvents(): void {\n    const node = !isMouse ? element : document\n    interactionEvents\n      .add(node, 'touchmove', move)\n      .add(node, 'touchend', up)\n      .add(node, 'mousemove', move)\n      .add(node, 'mouseup', up)\n  }\n\n  function isFocusNode(node: Element): boolean {\n    const name = node.nodeName || ''\n    return focusNodes.indexOf(name) > -1\n  }\n\n  function forceBoost(): number {\n    const boost = dragFree ? freeForceBoost : snapForceBoost\n    const type = isMouse ? 'mouse' : 'touch'\n    return boost[type]\n  }\n\n  function speedFactor(forceB: number, forceA: number): number {\n    const diff = delta(Math.abs(forceB), Math.abs(forceA))\n    if (Math.abs(forceB) <= Math.abs(forceA)) return 0\n    if (forceB === 0 || forceA === 0) return 0\n    return Math.abs(diff / forceB)\n  }\n\n  function allowedForce(force: number): number {\n    const { scrollTarget, index } = params\n    const currentLocation = scrollTarget.byDistance(0, false)\n    const targetChanged = currentLocation.index !== index.get()\n    const seekNext = !targetChanged && Math.abs(force) > dragThreshold\n    const destination = force + location.get()\n\n    if (seekNext && !dragFree && !limit.reachedAny(destination)) {\n      const next = index.clone().add(Direction(force).get() * -1)\n      return scrollTarget.byIndex(next.get(), 0).distance\n    }\n    if (!params.loop && edgeLimit.reachedAny(destination)) {\n      const edge = edgeLimit.reachedMax(destination) ? 'max' : 'min'\n      return edgeLimit[edge] - target.get()\n    }\n    return scrollTarget.byDistance(force, !dragFree).distance\n  }\n\n  function down(evt: Event): void {\n    isMouse = evt.type === 'mousedown'\n    if (isMouse && (evt as MouseEvent).button !== 0) return\n\n    const isMoving = delta(target.get(), location.get()) >= 2\n    const clearPreventClick = isMouse || !isMoving\n    const isNotFocusNode = !isFocusNode(evt.target as Element)\n    const preventDefault = isMoving || (isMouse && isNotFocusNode)\n\n    pointerIsDown = true\n    dragTracker.pointerDown(evt)\n    dragStartPoint.set(target)\n    target.set(location)\n    scrollBody.useDefaultMass().useSpeed(80)\n    addInteractionEvents()\n    startScroll.set(dragTracker.readPoint(evt, scrollAxis))\n    startCross.set(dragTracker.readPoint(evt, crossAxis))\n    events.emit('pointerDown')\n\n    if (clearPreventClick) preventClick = false\n    if (preventDefault) evt.preventDefault()\n  }\n\n  function move(evt: Event): void {\n    if (!preventScroll && !isMouse) {\n      const moveScroll = dragTracker.readPoint(evt, scrollAxis).get()\n      const moveCross = dragTracker.readPoint(evt, crossAxis).get()\n      const diffScroll = delta(moveScroll, startScroll.get())\n      const diffCross = delta(moveCross, startCross.get())\n      preventScroll = diffScroll > diffCross\n      if (!preventScroll && !preventClick) return up()\n    }\n    const diff = dragTracker.pointerMove(evt)\n    const reachedLimit = limit.reachedAny(location.get())\n    const resist = !params.loop && reachedLimit ? 2 : 1\n\n    if (!preventClick && diff) preventClick = true\n    animation.start()\n    target.add(diff / resist)\n    evt.preventDefault()\n  }\n\n  function up(): void {\n    const { scrollTo } = params\n    const rawForce = dragTracker.pointerUp() * forceBoost()\n    const force = allowedForce(rawForce)\n    const factor = speedFactor(rawForce, force)\n    const isMoving = delta(target.get(), dragStartPoint.get()) >= 0.5\n\n    if (isMoving && !isMouse) preventClick = true\n    preventScroll = false\n    pointerIsDown = false\n    interactionEvents.removeAll()\n    scrollBody.useSpeed(baseSpeed + baseSpeed * factor)\n    scrollTo.distance(force, !dragFree)\n    isMouse = false\n    events.emit('pointerUp')\n  }\n\n  function delta(pointB: number, pointA: number): number {\n    return Math.abs(pointB - pointA)\n  }\n\n  function click(evt: Event): void {\n    if (preventClick) evt.preventDefault()\n  }\n\n  function clickAllowed(): boolean {\n    return !preventClick\n  }\n\n  function pointerDown(): boolean {\n    return pointerIsDown\n  }\n\n  const self: DragHandler = {\n    addActivationEvents,\n    clickAllowed,\n    pointerDown,\n    removeActivationEvents,\n    removeInteractionEvents,\n  }\n  return self\n}\n","import { Axis, AxisOption } from './axis'\nimport { PxToPercent } from './pxToPercent'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  axis: Axis\n  pxToPercent: PxToPercent\n}\n\nexport type DragTracker = {\n  pointerDown: (evt: Event) => number\n  pointerMove: (evt: Event) => number\n  pointerUp: () => number\n  readPoint: (evt: any, axis: AxisOption) => Vector1D\n}\n\nexport function DragTracker(params: Params): DragTracker {\n  const { axis, pxToPercent } = params\n  const { scroll: scrollAxis } = axis\n  const coords = { x: 'clientX', y: 'clientY' }\n  const startDrag = Vector1D(0)\n  const diffDrag = Vector1D(0)\n  const lastDrag = Vector1D(0)\n  const pointValue = Vector1D(0)\n  const trackInterval = 10\n  const trackLength = 5\n  const trackTime = 100\n  let trackPoints: number[] = []\n  let lastMoveTime = new Date().getTime()\n  let isMouse = false\n\n  function readPoint(evt: any, type: AxisOption): Vector1D {\n    isMouse = !evt.touches\n    const c = coords[type]\n    const value = isMouse ? evt[c] : evt.touches[0][c]\n    return pointValue.set(value)\n  }\n\n  function pointerDown(evt: Event): number {\n    const point = readPoint(evt, scrollAxis)\n    startDrag.set(point)\n    lastDrag.set(point)\n    return pxToPercent.measure(startDrag.get())\n  }\n\n  function pointerMove(evt: Event): number {\n    const point = readPoint(evt, scrollAxis)\n    const nowTime = new Date().getTime()\n    const diffTime = nowTime - lastMoveTime\n\n    if (diffTime >= trackInterval) {\n      if (diffTime >= trackTime) trackPoints = []\n      trackPoints.push(point.get())\n      lastMoveTime = nowTime\n    }\n\n    diffDrag.set(point).subtract(lastDrag)\n    lastDrag.set(point)\n    return pxToPercent.measure(diffDrag.get())\n  }\n\n  function pointerUp(): number {\n    const nowTime = new Date().getTime()\n    const diffTime = nowTime - lastMoveTime\n    const currentPoint = lastDrag.get()\n\n    const force = trackPoints\n      .slice(-trackLength)\n      .map(trackPoint => currentPoint - trackPoint)\n      .sort((p1, p2) => (Math.abs(p1) < Math.abs(p2) ? 1 : -1))[0]\n\n    lastDrag.set(diffTime > trackTime || !force ? 0 : force)\n    trackPoints = []\n    return pxToPercent.measure(lastDrag.get())\n  }\n\n  const self: DragTracker = {\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint,\n  }\n  return self\n}\n","export function map(\n  value: number,\n  iStart: number,\n  iStop: number,\n  oStart: number,\n  oStop: number,\n): number {\n  return (\n    oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart))\n  )\n}\n\nexport function arrayFromCollection(\n  nodeList: HTMLCollection,\n): HTMLElement[] {\n  return Array.prototype.slice.call(nodeList)\n}\n\nexport function debounce(\n  callback: () => void,\n  time: number,\n): () => void {\n  const timeout = { id: 0 }\n  return (): void => {\n    window.clearTimeout(timeout.id)\n    timeout.id = window.setTimeout(callback, time) || 0\n  }\n}\n\nexport function roundToDecimals(\n  decimalPoints: number,\n): (n: number) => number {\n  const pow = Math.pow(10, decimalPoints)\n  return (n: number) => Math.round(n * pow) / pow\n}\n\nexport function groupArray<GenericType>(\n  array: GenericType[],\n  size: number,\n): GenericType[][] {\n  const groups = []\n  for (let i = 0; i < array.length; i += size) {\n    groups.push(array.slice(i, i + size))\n  }\n  return groups\n}\n\nexport function arrayKeys<GenericType>(array: GenericType): number[] {\n  return Object.keys(array).map(Number)\n}\n\nexport function removeClass(\n  node: HTMLElement,\n  className: string,\n): void {\n  const cl = node.classList\n  if (cl.contains(className)) cl.remove(className)\n}\n\nexport function addClass(node: HTMLElement, className: string): void {\n  const cl = node.classList\n  if (!cl.contains(className)) cl.add(className)\n}\n","import { Direction } from './direction'\nimport { map, roundToDecimals } from './utils'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  location: Vector1D\n  speed: number\n  mass: number\n}\n\nexport type ScrollBody = {\n  location: Vector1D\n  direction: Direction\n  update: () => void\n  seek: (v: Vector1D) => ScrollBody\n  settle: (v: Vector1D) => boolean\n  useSpeed: (n: number) => ScrollBody\n  useDefaultSpeed: () => ScrollBody\n  useMass: (n: number) => ScrollBody\n  useDefaultMass: () => ScrollBody\n}\n\nexport function ScrollBody(params: Params): ScrollBody {\n  const { location, speed, mass } = params\n  const roundToTwoDecimals = roundToDecimals(2)\n  const velocity = Vector1D(0)\n  const acceleration = Vector1D(0)\n  const attraction = Vector1D(0)\n  const direction = Direction(0)\n  const state = { speed, mass }\n\n  function update(): void {\n    velocity.add(acceleration)\n    location.add(velocity)\n    acceleration.multiply(0)\n  }\n\n  function applyForce(v: Vector1D): void {\n    v.divide(state.mass)\n    acceleration.add(v)\n  }\n\n  function seek(v: Vector1D): ScrollBody {\n    attraction.set(v).subtract(location)\n    const magnitude = attraction.get()\n    const m = map(magnitude, 0, 100, 0, state.speed)\n    direction.set(attraction)\n    attraction\n      .normalize()\n      .multiply(m)\n      .subtract(velocity)\n    applyForce(attraction)\n    return self\n  }\n\n  function settle(v: Vector1D): boolean {\n    const diff = v.get() - location.get()\n    const diffRounded = roundToTwoDecimals(diff)\n    const hasSettled = !diffRounded\n    if (hasSettled) location.set(v)\n    return hasSettled\n  }\n\n  function useSpeed(n: number): ScrollBody {\n    state.speed = n\n    return self\n  }\n\n  function useDefaultSpeed(): ScrollBody {\n    useSpeed(speed)\n    return self\n  }\n\n  function useMass(n: number): ScrollBody {\n    state.mass = n\n    return self\n  }\n\n  function useDefaultMass(): ScrollBody {\n    useMass(mass)\n    return self\n  }\n\n  const self: ScrollBody = {\n    direction,\n    location,\n    seek,\n    settle,\n    update,\n    useDefaultMass,\n    useDefaultSpeed,\n    useMass,\n    useSpeed,\n  }\n  return self\n}\n","import { Animation } from './animation'\nimport { Limit } from './limit'\nimport { ScrollBody } from './scrollBody'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  limit: Limit\n  location: Vector1D\n  scrollBody: ScrollBody\n  animation: Animation\n}\n\nexport type ScrollBounds = {\n  constrain: (v: Vector1D) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function ScrollBounds(params: Params): ScrollBounds {\n  const { limit, location, scrollBody, animation } = params\n  const { min, max, reachedMin, reachedMax } = limit\n  const tolerance = 50\n  let disabled = false\n  let timeout = 0\n\n  function shouldConstrain(v: Vector1D): boolean {\n    if (disabled || timeout) return false\n    if (reachedMin(location.get())) return v.get() !== min\n    if (reachedMax(location.get())) return v.get() !== max\n    return false\n  }\n\n  function constrain(v: Vector1D): void {\n    if (!shouldConstrain(v)) return\n\n    timeout = window.setTimeout(() => {\n      const constraint = limit.constrain(v.get())\n      v.set(constraint)\n      scrollBody.useSpeed(10).useMass(3)\n      animation.start()\n      timeout = 0\n    }, tolerance)\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  const self: ScrollBounds = {\n    constrain,\n    toggleActive,\n  }\n  return self\n}\n","import { Alignment } from './alignment'\nimport { Limit } from './limit'\n\nexport type ScrollContainOption = '' | 'trimSnaps' | 'keepSnaps'\n\ntype Params = {\n  contentSize: number\n  viewSize: number\n  alignment: Alignment\n}\n\nexport type ScrollContain = {\n  measure: (scrollSnaps: number[], trim: boolean) => number[]\n}\n\nexport function ScrollContain(params: Params): ScrollContain {\n  const { alignment, contentSize, viewSize } = params\n  const scrollBounds = Limit({ min: -contentSize + viewSize, max: 0 })\n  const alignedWithinView = [alignment.measure(contentSize)]\n  const contentExceedsView = contentSize > viewSize\n\n  function findDuplicates(scrollSnaps: number[]): Limit {\n    const startSnap = scrollSnaps[0]\n    const endSnap = scrollSnaps[scrollSnaps.length - 1]\n    const min = scrollSnaps.lastIndexOf(startSnap) + 1\n    const max = scrollSnaps.indexOf(endSnap)\n    return Limit({ min, max })\n  }\n\n  function measure(scrollSnaps: number[], trim: boolean): number[] {\n    const containedSnaps = scrollSnaps.map(scrollBounds.constrain)\n    const { min, max } = findDuplicates(containedSnaps)\n\n    if (!contentExceedsView) return alignedWithinView\n    if (!trim) return containedSnaps\n    return containedSnaps.slice(min - 1, max + 1)\n  }\n\n  const self: ScrollContain = {\n    measure,\n  }\n  return self\n}\n","import { Limit } from './limit'\nimport { PxToPercent } from './pxToPercent'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  contentSize: number\n  limit: Limit\n  location: Vector1D\n  pxToPercent: PxToPercent\n}\n\nexport type ScrollLooper = {\n  loop: (vectors: Vector1D[], direction: number) => void\n}\n\nexport function ScrollLooper(params: Params): ScrollLooper {\n  const { contentSize, location, limit, pxToPercent } = params\n  const min = limit.min + pxToPercent.measure(0.1)\n  const max = limit.max + pxToPercent.measure(0.1)\n  const { reachedMin, reachedMax } = Limit({ min, max })\n\n  function shouldLoop(direction: number): boolean {\n    if (direction === 1) return reachedMax(location.get())\n    if (direction === -1) return reachedMin(location.get())\n    return false\n  }\n\n  function loop(vectors: Vector1D[], direction: number): void {\n    if (!shouldLoop(direction)) return\n\n    const loopDistance = contentSize * (direction * -1)\n    vectors.forEach(v => v.add(loopDistance))\n  }\n\n  const self: ScrollLooper = {\n    loop,\n  }\n  return self\n}\n","import { Counter } from './counter'\nimport { Limit } from './limit'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  index: Counter\n  loop: boolean\n  scrollSnaps: number[]\n  contentSize: number\n  limit: Limit\n  target: Vector1D\n}\n\nexport type Target = {\n  distance: number\n  index: number\n}\n\nexport type ScrollTarget = {\n  byIndex: (target: number, direction: number) => Target\n  byDistance: (force: number, snap: boolean) => Target\n  shortcut: (target: number, direction: number) => number\n}\n\nexport function ScrollTarget(params: Params): ScrollTarget {\n  const { loop, limit, scrollSnaps, contentSize } = params\n  const { reachedMax, reachedAny, removeOffset } = limit\n\n  function minDistance(d1: number, d2: number): number {\n    return Math.abs(d1) < Math.abs(d2) ? d1 : d2\n  }\n\n  function findTargetSnap(target: number): Target {\n    const distance = removeOffset(target)\n    const ascDiffsToSnaps = scrollSnaps\n      .map(scrollSnap => scrollSnap - distance)\n      .map(diffToSnap => shortcut(diffToSnap, 0))\n      .map((diff, i) => ({ diff, index: i }))\n      .sort((d1, d2) => Math.abs(d1.diff) - Math.abs(d2.diff))\n\n    const { index } = ascDiffsToSnaps[0]\n    return { index, distance }\n  }\n\n  function shortcut(target: number, direction: number): number {\n    const t1 = target\n    const t2 = target + contentSize\n    const t3 = target - contentSize\n\n    if (!loop) return t1\n    if (!direction) return minDistance(minDistance(t1, t2), t3)\n\n    const shortest = minDistance(t1, direction === 1 ? t2 : t3)\n    return Math.abs(shortest) * direction\n  }\n\n  function findTargetIndex(target: number, index: number): number {\n    const reachedBound = !loop && reachedAny(target)\n    if (!reachedBound) return index\n\n    const { min, max } = params.index\n    return reachedMax(target) ? min : max\n  }\n\n  function byIndex(index: number, direction: number): Target {\n    const diffToSnap = scrollSnaps[index] - params.target.get()\n    const distance = shortcut(diffToSnap, direction)\n    return { index, distance }\n  }\n\n  function byDistance(distance: number, snap: boolean): Target {\n    const target = params.target.get() + distance\n    const targetSnap = findTargetSnap(target)\n    const index = findTargetIndex(target, targetSnap.index)\n    const reachedBound = !loop && reachedAny(target)\n\n    if (!snap || reachedBound) return { index, distance }\n\n    const diffToSnap = scrollSnaps[index] - targetSnap.distance\n    const snapDistance = distance + shortcut(diffToSnap, 0)\n\n    return { index, distance: snapDistance }\n  }\n\n  const self: ScrollTarget = {\n    byDistance,\n    byIndex,\n    shortcut,\n  }\n  return self\n}\n","import { Axis } from './axis'\nimport { arrayKeys } from './utils'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  axis: Axis\n  scrollSnaps: number[]\n  viewSize: number\n  location: Vector1D\n  slideSizes: number[]\n  contentSize: number\n}\n\ntype LoopPoint = {\n  point: number\n  location: number\n  index: number\n  getTarget: (location: number) => number\n}\n\nexport type SlideLooper = {\n  canLoop: () => boolean\n  clear: (slides: HTMLElement[]) => void\n  loop: (slides: HTMLElement[]) => void\n  loopPoints: LoopPoint[]\n}\n\nexport function SlideLooper(params: Params): SlideLooper {\n  const { axis, location: containerLocation } = params\n  const { contentSize, viewSize, slideSizes, scrollSnaps } = params\n  const ascItems = arrayKeys(slideSizes)\n  const descItems = arrayKeys(slideSizes).reverse()\n  const loopPoints = startPoints().concat(endPoints())\n  const loopStyle = axis.scroll === 'x' ? 'left' : 'top'\n\n  function subtractItemSizes(\n    indexes: number[],\n    from: number,\n  ): number {\n    return indexes.reduce((a: number, i) => {\n      const size = slideSizes[i]\n      return a - size\n    }, from)\n  }\n\n  function loopItemsIn(\n    sizeOfGap: number,\n    indexes: number[],\n  ): number[] {\n    return indexes.reduce((a: number[], i) => {\n      const gapLeft = subtractItemSizes(a, sizeOfGap)\n      return gapLeft > 0 ? a.concat([i]) : a\n    }, [])\n  }\n\n  function loopStart(\n    sizeOfGap: number,\n    indexes: number[],\n    from: number,\n  ): number {\n    return indexes.reduce((a: number, i) => {\n      const gapFilled = a + slideSizes[i]\n      return gapFilled < sizeOfGap ? gapFilled : a\n    }, from)\n  }\n\n  function loopPointFor(\n    indexes: number[],\n    from: number,\n    direction: 0 | 1,\n  ): number {\n    const slideCount = ascItems.length - 1\n    return subtractItemSizes(\n      indexes.map(i => (i + direction) % slideCount),\n      from,\n    )\n  }\n\n  function loopPointsFor(\n    indexes: number[],\n    from: number,\n    direction: 0 | 1,\n  ): LoopPoint[] {\n    const ascIndexes = indexes.slice().sort((a, b) => a - b)\n    return ascIndexes.map(\n      (index, loopIndex): LoopPoint => {\n        const initial = contentSize * (!direction ? 0 : -1)\n        const offset = contentSize * (!direction ? 1 : 0)\n        const slidesInSpan = ascIndexes.slice(0, loopIndex)\n        const point = loopPointFor(slidesInSpan, from, direction)\n        const getTarget = (location: number): number =>\n          location > point ? initial : offset\n        return { point, getTarget, index, location: -1 }\n      },\n    )\n  }\n\n  function startPoints(): LoopPoint[] {\n    const gap = scrollSnaps[0] - 1\n    const indexes = loopItemsIn(gap, descItems)\n    const start = loopStart(gap, indexes, 0)\n    return loopPointsFor(indexes, start, 1)\n  }\n\n  function endPoints(): LoopPoint[] {\n    const gap = viewSize - scrollSnaps[0] - 1\n    const indexes = loopItemsIn(gap, ascItems)\n    const start = loopStart(contentSize, ascItems, -viewSize)\n    return loopPointsFor(indexes, -start, 0)\n  }\n\n  function canLoop(): boolean {\n    return loopPoints.every(({ index }) => {\n      const otherIndexes = ascItems.filter(i => i !== index)\n      return subtractItemSizes(otherIndexes, viewSize) <= 0\n    })\n  }\n\n  function loop(slides: HTMLElement[]): void {\n    loopPoints.forEach(loopPoint => {\n      const { getTarget, location, index } = loopPoint\n      const target = getTarget(containerLocation.get())\n      if (target !== location) {\n        slides[index].style[loopStyle] = `${target}%`\n        loopPoint.location = target\n      }\n    })\n  }\n\n  function clear(slides: HTMLElement[]): void {\n    loopPoints.forEach(({ index }) => {\n      slides[index].style[loopStyle] = ''\n    })\n  }\n\n  const self: SlideLooper = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints,\n  }\n  return self\n}\n","import { arrayKeys } from './utils'\n\ntype Params = {\n  contentSize: number\n  slideSizes: number[]\n  viewSize: number\n  loop: boolean\n  inViewThreshold: number\n}\n\ntype SlidePoint = {\n  start: number\n  end: number\n  index: number\n}\n\nexport type SlidesInView = {\n  check: (location: number) => number[]\n}\n\nexport function SlidesInView(params: Params): SlidesInView {\n  const { contentSize, slideSizes, viewSize } = params\n  const { inViewThreshold, loop } = params\n  const thresholds = slideSizes.map(s => s * inViewThreshold)\n  const scrollSnaps = arrayKeys(slideSizes).map(scrollSnap)\n  const pointsToCheck = concatSlidePoints()\n\n  function scrollSnap(index: number): number {\n    const span = slideSizes.slice(0, index)\n    return span.reduce((a, s) => a - s, 0)\n  }\n\n  function concatSlidePoints(): SlidePoint[] {\n    const offsets = loop ? [0, contentSize, -contentSize] : [0]\n    return offsets.map(slidePoints).reduce((a, b) => a.concat(b), [])\n  }\n\n  function slidePoints(offset: number): SlidePoint[] {\n    return scrollSnaps.map((snap, index) => ({\n      start: snap - slideSizes[index] + thresholds[index] + offset,\n      end: snap + viewSize - thresholds[index] + offset,\n      index,\n    }))\n  }\n\n  function check(location: number): number[] {\n    return pointsToCheck.reduce((list: number[], point) => {\n      const { index, start, end } = point\n      const inList = list.indexOf(index) !== -1\n      const inView = start < location && end > location\n      return !inList && inView ? list.concat([index]) : list\n    }, [])\n  }\n\n  const self: SlidesInView = {\n    check,\n  }\n  return self\n}\n","import { Axis } from './axis'\nimport { roundToDecimals } from './utils'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  axis: Axis\n  container: HTMLElement\n}\n\nexport type Translate = {\n  clear: () => void\n  to: (vector: Vector1D) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function Translate(params: Params): Translate {\n  const { axis, container } = params\n  const translates = { x, y }\n  const translateAxis = translates[axis.scroll]\n  const roundToTwoDecimals = roundToDecimals(2)\n  const containerStyle = container.style\n  let disabled = false\n  let location = 0\n\n  function x(n: number): string {\n    return `translate3d(${n}%,0px,0px)`\n  }\n\n  function y(n: number): string {\n    return `translate3d(0px,${n}%,0px)`\n  }\n\n  function to(v: Vector1D): void {\n    if (disabled) return\n    const target = roundToTwoDecimals(v.get())\n\n    if (location !== target) {\n      getComputedStyle(container).transform\n      containerStyle.transform = translateAxis(target)\n      location = target\n    }\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  function clear(): void {\n    containerStyle.transform = ''\n    location = 0\n  }\n\n  const self: Translate = {\n    clear,\n    to,\n    toggleActive,\n  }\n  return self\n}\n","import { Alignment } from './alignment'\nimport { Animation } from './animation'\nimport { Axis } from './axis'\nimport { Counter } from './counter'\nimport { DragHandler } from './dragHandler'\nimport { DragTracker } from './dragTracker'\nimport { EventEmitter } from './eventEmitter'\nimport { Limit } from './limit'\nimport { Options } from './options'\nimport { PxToPercent } from './pxToPercent'\nimport { ScrollBody } from './scrollBody'\nimport { ScrollBounds } from './scrollBounds'\nimport { ScrollContain } from './scrollContain'\nimport { ScrollLimit } from './scrollLimit'\nimport { ScrollLooper } from './scrollLooper'\nimport { ScrollProgress } from './scrollProgress'\nimport { ScrollSnap } from './scrollSnap'\nimport { ScrollTarget } from './scrollTarget'\nimport { ScrollTo } from './scrollTo'\nimport { SlideLooper } from './slideLooper'\nimport { SlidesInView } from './slidesInView'\nimport { Translate } from './translate'\nimport { arrayKeys, groupArray } from './utils'\nimport { Vector1D } from './vector1d'\n\nexport type Engine = {\n  axis: Axis\n  animation: Animation\n  scrollBounds: ScrollBounds\n  scrollLooper: ScrollLooper\n  scrollProgress: ScrollProgress\n  index: Counter\n  indexPrevious: Counter\n  limit: Limit\n  location: Vector1D\n  options: Options\n  pxToPercent: PxToPercent\n  scrollBody: ScrollBody\n  dragHandler: DragHandler\n  slideLooper: SlideLooper\n  slidesInView: SlidesInView\n  target: Vector1D\n  translate: Translate\n  scrollTo: ScrollTo\n  scrollTarget: ScrollTarget\n  scrollSnaps: number[]\n  snapIndexes: number[]\n}\n\nexport function Engine(\n  root: HTMLElement,\n  container: HTMLElement,\n  slides: HTMLElement[],\n  options: Options,\n  events: EventEmitter,\n): Engine {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    startIndex,\n    inViewThreshold,\n    loop,\n    speed,\n    dragFree,\n    slidesToScroll,\n    containScroll,\n  } = options\n\n  // Measurements\n  const axis = Axis(scrollAxis)\n  const pxToPercent = PxToPercent(axis.measure(container))\n  const viewSize = pxToPercent.totalPercent\n  const slideSizes = slides.map(axis.measure).map(pxToPercent.measure)\n  const groupedSizes = groupArray(slideSizes, slidesToScroll)\n  const snapSizes = groupedSizes.map(g => g.reduce((a, s) => a + s))\n  const snapIndexes = arrayKeys(snapSizes)\n  const contentSize = slideSizes.reduce((a, s) => a + s, 0)\n  const alignment = Alignment({ align, viewSize })\n  const scrollSnap = ScrollSnap({ snapSizes, alignment, loop })\n  const defaultSnaps = snapIndexes.map(scrollSnap.measure)\n  const contain = ScrollContain({ alignment, contentSize, viewSize })\n  const shouldContain = !loop && containScroll !== ''\n  const trimSnaps = containScroll === 'trimSnaps'\n  const containedSnaps = contain.measure(defaultSnaps, trimSnaps)\n  const scrollSnaps = shouldContain ? containedSnaps : defaultSnaps\n\n  // Index\n  const indexMax = Math.max(0, scrollSnaps.length - 1)\n  const indexSpan = Limit({ min: 0, max: indexMax })\n  const index = Counter({ limit: indexSpan, start: startIndex, loop })\n  const indexPrevious = index.clone()\n\n  // ScrollLimit\n  const scrollLimit = ScrollLimit({ loop, contentSize })\n  const limit = scrollLimit.measure(scrollSnaps)\n\n  // Draw\n  const update = (): void => {\n    engine.scrollBody.seek(target).update()\n    const settled = engine.scrollBody.settle(target)\n\n    if (!dragHandler.pointerDown()) {\n      if (!loop) engine.scrollBounds.constrain(target)\n      if (settled) {\n        engine.animation.stop()\n        events.emit('settle')\n      }\n    }\n    if (loop) {\n      const direction = engine.scrollBody.direction.get()\n      engine.scrollLooper.loop(loopVectors, direction)\n      engine.slideLooper.loop(slides)\n    }\n\n    if (!settled) events.emit('scroll')\n    engine.translate.to(engine.scrollBody.location)\n    engine.animation.proceed()\n  }\n\n  // Shared\n  const animation = Animation(update)\n  const startLocation = scrollSnaps[index.get()]\n  const location = Vector1D(startLocation)\n  const target = Vector1D(startLocation)\n  const loopVectors = [location, target]\n  const scrollBody = ScrollBody({ location, speed, mass: 1 })\n  const scrollTarget = ScrollTarget({\n    contentSize,\n    index,\n    limit,\n    loop,\n    scrollSnaps,\n    target,\n  })\n  const scrollTo = ScrollTo({\n    animation,\n    events,\n    index,\n    indexPrevious,\n    scrollTarget,\n    target,\n  })\n\n  // DragHandler\n  const dragHandler = DragHandler({\n    animation,\n    axis,\n    dragFree,\n    dragTracker: DragTracker({\n      axis,\n      pxToPercent,\n    }),\n    element: root,\n    events,\n    index,\n    limit,\n    location,\n    loop,\n    scrollBody,\n    scrollTo,\n    scrollTarget,\n    target,\n  })\n\n  // Slider\n  const engine: Engine = {\n    animation,\n    axis,\n    dragHandler,\n    pxToPercent,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    options,\n    scrollBody,\n    scrollBounds: ScrollBounds({\n      animation,\n      limit,\n      location,\n      scrollBody,\n    }),\n    scrollLooper: ScrollLooper({\n      contentSize,\n      limit,\n      location,\n      pxToPercent,\n    }),\n    scrollProgress: ScrollProgress({\n      limit,\n    }),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideLooper: SlideLooper({\n      axis,\n      contentSize,\n      location,\n      scrollSnaps,\n      slideSizes,\n      viewSize,\n    }),\n    slidesInView: SlidesInView({\n      contentSize,\n      inViewThreshold,\n      loop,\n      slideSizes,\n      viewSize,\n    }),\n    snapIndexes,\n    target,\n    translate: Translate({\n      axis,\n      container,\n    }),\n  }\n  return engine\n}\n","export type PxToPercent = {\n  measure: (n: number) => number\n  totalPercent: number\n}\n\nexport function PxToPercent(viewInPx: number): PxToPercent {\n  const totalPercent = 100\n\n  function measure(n: number): number {\n    return (n / viewInPx) * totalPercent\n  }\n\n  const self: PxToPercent = {\n    measure,\n    totalPercent,\n  }\n  return self\n}\n","import { Limit } from './limit'\r\n\r\ntype Params = {\r\n  limit: Limit\r\n}\r\n\r\nexport type ScrollProgress = {\r\n  get: (n: number) => number\r\n}\r\n\r\nexport function ScrollProgress(params: Params): ScrollProgress {\r\n  const { max, length: scrollLength } = params.limit\r\n\r\n  function get(n: number): number {\r\n    const currentLocation = n - max\r\n    return currentLocation / -scrollLength\r\n  }\r\n\r\n  const self: ScrollProgress = {\r\n    get,\r\n  }\r\n  return self\r\n}\r\n","export type AxisOption = 'x' | 'y'\n\nexport type Axis = {\n  cross: AxisOption\n  scroll: AxisOption\n  measure: (node: HTMLElement) => number\n}\n\nexport function Axis(axis: AxisOption): Axis {\n  const scroll = axis === 'y' ? 'y' : 'x'\n  const cross = axis === 'y' ? 'x' : 'y'\n\n  function measure(node: HTMLElement): number {\n    const { width, height } = node.getBoundingClientRect()\n    return scroll === 'x' ? width : height\n  }\n\n  const self: Axis = {\n    cross,\n    measure,\n    scroll,\n  }\n  return self\n}\n","import { Alignment } from './alignment'\nimport { Counter } from './counter'\nimport { Limit } from './limit'\n\ntype Params = {\n  snapSizes: number[]\n  alignment: Alignment\n  loop: boolean\n}\n\nexport type ScrollSnap = {\n  measure: (index: number) => number\n}\n\nexport function ScrollSnap(params: Params): ScrollSnap {\n  const { snapSizes, alignment, loop } = params\n  const alignments = snapSizes.map(alignment.measure)\n  const distancesBetween = distancesBetweenScrollSnaps()\n\n  function distancesBetweenScrollSnaps(): number[] {\n    const limit = Limit({ min: 0, max: snapSizes.length - 1 })\n    const counter = Counter({ limit, start: 0, loop })\n\n    return snapSizes.map((size, index) => {\n      const next = counter.set(index + 1).get()\n      return size + alignments[index] - alignments[next]\n    })\n  }\n\n  function measure(index: number): number {\n    const sizes = distancesBetween.slice(0, index)\n    return sizes.reduce((a, s) => a - s, alignments[0])\n  }\n\n  const self: ScrollSnap = {\n    measure,\n  }\n  return self\n}\n","import { Limit } from './limit'\n\ntype Params = {\n  contentSize: number\n  loop: boolean\n}\n\nexport type ScrollLimit = {\n  measure: (scrollSnaps: number[]) => Limit\n}\n\nexport function ScrollLimit(params: Params): ScrollLimit {\n  const { contentSize, loop } = params\n\n  function measure(scrollSnaps: number[]): Limit {\n    const startSnap = scrollSnaps[0]\n    const endSnap = scrollSnaps[scrollSnaps.length - 1]\n    const min = loop ? startSnap - contentSize : endSnap\n    const max = startSnap\n    return Limit({ min, max })\n  }\n\n  const self: ScrollLimit = {\n    measure,\n  }\n  return self\n}\n","type Callback = () => void\n\nexport type Animation = {\n  start: () => void\n  stop: () => void\n  proceed: () => void\n}\n\nexport function Animation(callback: FrameRequestCallback): Animation {\n  // const run = requestAnimationFrame.bind(window)\n  // const end = cancelAnimationFrame.bind(window)\n  let animationFrame = 0\n\n  function ifAnimating(active: boolean, cb: Callback): Callback {\n    return (): void => {\n      if (active === !!animationFrame) cb()\n    }\n  }\n\n  function start(): void {\n    animationFrame = window.requestAnimationFrame(callback)\n  }\n\n  function stop(): void {\n    window.cancelAnimationFrame(animationFrame)\n    animationFrame = 0\n  }\n\n  const self: Animation = {\n    proceed: ifAnimating(true, start),\n    start: ifAnimating(false, start),\n    stop: ifAnimating(true, stop),\n  }\n  return self\n}\n","import { Animation } from './animation'\nimport { Counter } from './counter'\nimport { EventEmitter } from './eventEmitter'\nimport { ScrollTarget, Target } from './scrollTarget'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  animation: Animation\n  target: Vector1D\n  index: Counter\n  indexPrevious: Counter\n  scrollTarget: ScrollTarget\n  events: EventEmitter\n}\n\nexport type ScrollTo = {\n  distance: (n: number, snap: boolean) => void\n  index: (n: number, direction: number) => void\n}\n\nexport function ScrollTo(params: Params): ScrollTo {\n  const { index: indexCurrent, scrollTarget, animation } = params\n  const { indexPrevious, events, target: targetDistance } = params\n\n  function scrollTo(target: Target): void {\n    const distanceDiff = target.distance\n    const indexDiff = target.index !== indexCurrent.get()\n\n    if (distanceDiff) {\n      animation.start()\n      targetDistance.add(distanceDiff)\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get())\n      indexCurrent.set(target.index)\n      events.emit('select')\n    }\n  }\n\n  function distance(n: number, snap: boolean): void {\n    const target = scrollTarget.byDistance(n, snap)\n    scrollTo(target)\n  }\n\n  function index(n: number, direction: number): void {\n    const targetIndex = indexCurrent.clone().set(n)\n    const target = scrollTarget.byIndex(targetIndex.get(), direction)\n    scrollTo(target)\n  }\n\n  const self: ScrollTo = {\n    distance,\n    index,\n  }\n  return self\n}\n","import { AlignmentOption } from './alignment'\nimport { AxisOption } from './axis'\nimport { ScrollContainOption } from './scrollContain'\n\nexport type Options = {\n  align: AlignmentOption\n  axis: AxisOption\n  containScroll: ScrollContainOption\n  containerSelector: string\n  dragFree: boolean\n  draggable: boolean\n  draggableClass: string\n  draggingClass: string\n  inViewThreshold: number\n  loop: boolean\n  selectedClass: string\n  slidesToScroll: number\n  speed: number\n  startIndex: number\n}\n\nexport const defaultOptions: Options = {\n  align: 'center',\n  axis: 'x',\n  containScroll: '',\n  containerSelector: '*',\n  dragFree: false,\n  draggable: true,\n  draggableClass: 'is-draggable',\n  draggingClass: 'is-dragging',\n  inViewThreshold: 0,\n  loop: false,\n  selectedClass: 'is-selected',\n  slidesToScroll: 1,\n  speed: 10,\n  startIndex: 0,\n}\n\nexport type EmblaOptions = Partial<Options>\n","import { Engine } from './components/engine'\nimport { EventEmitter, EmblaEvent } from './components/eventEmitter'\nimport { EventStore } from './components/eventStore'\nimport { defaultOptions, EmblaOptions } from './components/options'\nimport {\n  addClass,\n  arrayFromCollection,\n  debounce,\n  removeClass,\n} from './components/utils'\n\nexport type EmblaCarousel = {\n  canScrollNext: () => boolean\n  canScrollPrev: () => boolean\n  clickAllowed: () => boolean\n  containerNode: () => HTMLElement\n  dangerouslyGetEngine: () => Engine\n  destroy: () => void\n  off: EventEmitter['off']\n  on: EventEmitter['on']\n  previousScrollSnap: () => number\n  reInit: (options?: EmblaOptions) => void\n  scrollNext: () => void\n  scrollPrev: () => void\n  scrollProgress: () => number\n  scrollSnapList: () => number[]\n  scrollTo: (index: number) => void\n  selectedScrollSnap: () => number\n  slideNodes: () => HTMLElement[]\n  slidesInView: (target?: boolean) => number[]\n  slidesNotInView: (target?: boolean) => number[]\n}\n\nfunction EmblaCarousel(\n  sliderRoot: HTMLElement,\n  userOptions: EmblaOptions = {},\n): EmblaCarousel {\n  const events = EventEmitter()\n  const eventStore = EventStore()\n  const debouncedResize = debounce(resize, 500)\n  const reInit = reActivate\n  const { on, off } = events\n\n  let engine: Engine\n  let activated = false\n  let options = Object.assign({}, defaultOptions)\n  let rootElementSize = 0\n  let container: HTMLElement\n  let slides: HTMLElement[]\n\n  activate(userOptions)\n\n  function storeElements(): void {\n    if (!sliderRoot) throw new Error('Missing root node 😢')\n\n    const selector = options.containerSelector\n    const sliderContainer = sliderRoot.querySelector(selector)\n\n    if (!sliderContainer) throw new Error('Missing container node 😢')\n\n    container = sliderContainer as HTMLElement\n    slides = arrayFromCollection(container.children)\n  }\n\n  function activate(partialOptions: EmblaOptions = {}): void {\n    storeElements()\n    options = Object.assign(options, partialOptions)\n    engine = Engine(sliderRoot, container, slides, options, events)\n\n    const {\n      axis,\n      scrollBody,\n      translate,\n      dragHandler,\n      slideLooper,\n    } = engine\n    const {\n      loop,\n      draggable,\n      draggableClass,\n      selectedClass,\n      draggingClass,\n    } = options\n\n    rootElementSize = axis.measure(sliderRoot)\n    eventStore.add(window, 'resize', debouncedResize)\n    translate.to(scrollBody.location)\n    slides.forEach(slideFocusEvent)\n    dragHandler.addActivationEvents()\n\n    if (loop) {\n      if (!slideLooper.canLoop()) return reActivate({ loop: false })\n      slideLooper.loop(slides)\n    }\n    if (draggable && slides.length) {\n      if (draggableClass) {\n        addClass(sliderRoot, draggableClass)\n      }\n      if (draggingClass) {\n        events.on('pointerDown', toggleDraggingClass)\n        events.on('pointerUp', toggleDraggingClass)\n      }\n    } else {\n      events.on('pointerDown', dragHandler.removeInteractionEvents)\n    }\n    if (selectedClass) {\n      toggleSelectedClass()\n      events.on('select', toggleSelectedClass)\n      events.on('pointerUp', toggleSelectedClass)\n    }\n    if (!activated) {\n      setTimeout(() => events.emit('init'), 0)\n      activated = true\n    }\n  }\n\n  function toggleDraggingClass(evt: EmblaEvent): void {\n    const { draggingClass } = options\n    if (evt === 'pointerDown') addClass(sliderRoot, draggingClass)\n    else removeClass(sliderRoot, draggingClass)\n  }\n\n  function toggleSelectedClass(): void {\n    const { selectedClass } = options\n    const inView = slidesInView(true)\n    const notInView = slidesNotInView(true)\n    notInView.forEach(i => removeClass(slides[i], selectedClass))\n    inView.forEach(i => addClass(slides[i], selectedClass))\n  }\n\n  function slideFocusEvent(slide: HTMLElement, index: number): void {\n    const focus = (): void => {\n      const groupIndex = Math.floor(index / options.slidesToScroll)\n      const selectedGroup = index ? groupIndex : index\n      sliderRoot.scrollLeft = 0\n      scrollTo(selectedGroup)\n    }\n    eventStore.add(slide, 'focus', focus, true)\n  }\n\n  function reActivate(partialOptions: EmblaOptions = {}): void {\n    const startIndex = selectedScrollSnap()\n    const newOptions = Object.assign({ startIndex }, partialOptions)\n    deActivate()\n    activate(newOptions)\n    events.emit('reInit')\n  }\n\n  function deActivate(): void {\n    engine.dragHandler.removeActivationEvents()\n    engine.dragHandler.removeInteractionEvents()\n    engine.animation.stop()\n    eventStore.removeAll()\n    engine.translate.clear()\n    engine.slideLooper.clear(slides)\n    removeClass(sliderRoot, options.draggableClass)\n    slides.forEach(s => removeClass(s, options.selectedClass))\n    events.off('select', toggleSelectedClass)\n    events.off('pointerUp', toggleSelectedClass)\n    events.off('pointerDown', toggleDraggingClass)\n    events.off('pointerUp', toggleDraggingClass)\n  }\n\n  function destroy(): void {\n    if (!activated) return\n    deActivate()\n    activated = false\n    engine = {} as Engine\n    events.emit('destroy')\n  }\n\n  function resize(): void {\n    const newRootElementSize = engine.axis.measure(sliderRoot)\n    if (rootElementSize !== newRootElementSize) reActivate()\n    events.emit('resize')\n  }\n\n  function slidesInView(target = false): number[] {\n    const location = engine[target ? 'target' : 'location'].get()\n    const type = options.loop ? 'removeOffset' : 'constrain'\n    return engine.slidesInView.check(engine.limit[type](location))\n  }\n\n  function slidesNotInView(target = false): number[] {\n    const inView = slidesInView(target)\n    return engine.snapIndexes.filter(i => inView.indexOf(i) === -1)\n  }\n\n  function scrollTo(index: number): void {\n    engine.scrollBody.useDefaultMass().useDefaultSpeed()\n    engine.scrollTo.index(index, 0)\n  }\n\n  function scrollNext(): void {\n    const next = engine.index.clone().add(1)\n    engine.scrollBody.useDefaultMass().useDefaultSpeed()\n    engine.scrollTo.index(next.get(), -1)\n  }\n\n  function scrollPrev(): void {\n    const prev = engine.index.clone().add(-1)\n    engine.scrollBody.useDefaultMass().useDefaultSpeed()\n    engine.scrollTo.index(prev.get(), 1)\n  }\n\n  function canScrollNext(): boolean {\n    const next = engine.index.clone().add(1)\n    return next.get() !== selectedScrollSnap()\n  }\n\n  function canScrollPrev(): boolean {\n    const prev = engine.index.clone().add(-1)\n    return prev.get() !== selectedScrollSnap()\n  }\n\n  function scrollSnapList(): number[] {\n    return engine.scrollSnaps.map(engine.scrollProgress.get)\n  }\n\n  function scrollProgress(): number {\n    return engine.scrollProgress.get(engine.location.get())\n  }\n\n  function selectedScrollSnap(): number {\n    return engine.index.get()\n  }\n\n  function previousScrollSnap(): number {\n    return engine.indexPrevious.get()\n  }\n\n  function clickAllowed(): boolean {\n    return engine.dragHandler.clickAllowed()\n  }\n\n  function dangerouslyGetEngine(): Engine {\n    return engine\n  }\n\n  function containerNode(): HTMLElement {\n    return container\n  }\n\n  function slideNodes(): HTMLElement[] {\n    return slides\n  }\n\n  const self: EmblaCarousel = {\n    canScrollNext,\n    canScrollPrev,\n    clickAllowed,\n    containerNode,\n    dangerouslyGetEngine,\n    destroy,\n    off,\n    on,\n    previousScrollSnap,\n    reInit,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView,\n  }\n  return self\n}\n\nexport default EmblaCarousel\n","type Callback = (evt: EmblaEvent) => void\ntype Listeners = { [key in EmblaEvent]: Callback[] }\n\nexport type EmblaEvent =\n  | 'init'\n  | 'pointerDown'\n  | 'pointerUp'\n  | 'scroll'\n  | 'select'\n  | 'settle'\n  | 'destroy'\n  | 'reInit'\n  | 'resize'\n\nexport type EventEmitter = {\n  emit: (evt: EmblaEvent) => EventEmitter\n  on: (evt: EmblaEvent, cb: Callback) => EventEmitter\n  off: (evt: EmblaEvent, cb: Callback) => EventEmitter\n}\n\nexport function EventEmitter(): EventEmitter {\n  const listeners: Listeners = {\n    destroy: [],\n    pointerDown: [],\n    pointerUp: [],\n    init: [],\n    reInit: [],\n    resize: [],\n    scroll: [],\n    select: [],\n    settle: [],\n  }\n\n  function emit(evt: EmblaEvent): EventEmitter {\n    listeners[evt].forEach(e => e(evt))\n    return self\n  }\n\n  function on(evt: EmblaEvent, cb: Callback): EventEmitter {\n    listeners[evt] = listeners[evt].concat([cb])\n    return self\n  }\n\n  function off(evt: EmblaEvent, cb: Callback): EventEmitter {\n    listeners[evt] = listeners[evt].filter(e => e !== cb)\n    return self\n  }\n\n  const self: EventEmitter = {\n    emit,\n    off,\n    on,\n  }\n  return self\n}\n"],"names":["Alignment","params","viewSize","align","predefined","start","center","n","end","measure","Number","Counter","limit","loop","min","max","withinLimit","counter","get","set","self","add","sign","Math","abs","clone","Vector1D","value","vector","divide","readNumber","multiply","normalize","subtract","Direction","direction","v","d","EventStore","listeners","node","type","handler","options","addEventListener","push","removeEventListener","removeAll","filter","remove","Limit","loopLimits","constrainLimits","length","reachedMin","reachedMax","reachedWhich","constrain","which","reachedAny","removeOffset","DragHandler","target","scrollBody","dragFree","animation","axis","element","dragTracker","location","events","scrollAxis","crossAxis","focusNodes","startScroll","startCross","dragStartPoint","activationEvents","interactionEvents","removeActivationEvents","removeInteractionEvents","snapForceBoost","mouse","touch","freeForceBoost","baseSpeed","edgeLimit","pointerIsDown","preventScroll","preventClick","isMouse","down","evt","button","name","isMoving","delta","clearPreventClick","isNotFocusNode","nodeName","indexOf","preventDefault","pointerDown","useDefaultMass","useSpeed","document","move","up","addInteractionEvents","readPoint","emit","moveScroll","moveCross","diffScroll","diffCross","diff","pointerMove","reachedLimit","resist","forceB","forceA","scrollTo","rawForce","pointerUp","force","scrollTarget","index","seekNext","byDistance","destination","next","byIndex","distance","edge","allowedForce","factor","pointB","pointA","click","addActivationEvents","clickAllowed","DragTracker","pxToPercent","coords","x","y","startDrag","diffDrag","lastDrag","pointValue","trackPoints","lastMoveTime","Date","getTime","touches","c","point","nowTime","diffTime","currentPoint","slice","map","trackPoint","sort","p1","p2","roundToDecimals","decimalPoints","pow","round","arrayKeys","array","Object","keys","removeClass","className","cl","classList","contains","addClass","ScrollBody","speed","mass","roundToTwoDecimals","velocity","acceleration","attraction","state","useMass","seek","iStart","iStop","oStart","oStop","magnitude","m","applyForce","settle","hasSettled","update","useDefaultSpeed","ScrollBounds","disabled","timeout","shouldConstrain","window","setTimeout","constraint","toggleActive","active","ScrollContain","alignment","contentSize","scrollBounds","alignedWithinView","contentExceedsView","scrollSnaps","trim","containedSnaps","_a","startSnap","endSnap","lastIndexOf","findDuplicates","ScrollLooper","vectors","shouldLoop","loopDistance","forEach","ScrollTarget","minDistance","d1","d2","shortcut","t1","t2","t3","shortest","snap","targetSnap","scrollSnap","diffToSnap","i","findTargetSnap","findTargetIndex","reachedBound","SlideLooper","gap","indexes","containerLocation","slideSizes","ascItems","descItems","reverse","loopPoints","loopItemsIn","loopStart","loopPointsFor","concat","endPoints","loopStyle","scroll","subtractItemSizes","from","reduce","a","sizeOfGap","gapFilled","ascIndexes","b","loopIndex","initial","offset","slideCount","loopPointFor","getTarget","canLoop","every","clear","slides","style","loopPoint","SlidesInView","inViewThreshold","thresholds","s","pointsToCheck","slidePoints","check","list","Translate","container","translateAxis","containerStyle","transform","to","getComputedStyle","Engine","root","viewInPx","scrollLength","startIndex","slidesToScroll","containScroll","cross","getBoundingClientRect","width","height","Axis","totalPercent","snapSizes","size","groups","groupArray","g","snapIndexes","alignments","distancesBetween","ScrollSnap","defaultSnaps","contain","shouldContain","trimSnaps","indexPrevious","ScrollLimit","callback","animationFrame","ifAnimating","cb","requestAnimationFrame","proceed","stop","cancelAnimationFrame","Animation","engine","settled","dragHandler","scrollLooper","loopVectors","slideLooper","translate","startLocation","indexCurrent","targetDistance","distanceDiff","indexDiff","targetIndex","ScrollTo","scrollProgress","slidesInView","defaultOptions","containerSelector","draggable","draggableClass","draggingClass","selectedClass","sliderRoot","userOptions","time","destroy","init","reInit","resize","select","e","off","on","EventEmitter","eventStore","debouncedResize","newRootElementSize","rootElementSize","reActivate","id","clearTimeout","activated","_extends","storeElements","Error","nodeList","selector","sliderContainer","querySelector","children","Array","prototype","call","activate","partialOptions","slideFocusEvent","toggleDraggingClass","toggleSelectedClass","inView","slidesNotInView","slide","groupIndex","floor","selectedGroup","scrollLeft","newOptions","selectedScrollSnap","deActivate","canScrollNext","canScrollPrev","containerNode","dangerouslyGetEngine","previousScrollSnap","scrollNext","scrollPrev","prev","scrollSnapList","slideNodes"],"mappings":"4ZAWgBA,EAAUC,OAChBC,EAAoBD,WAAVE,EAAUF,QACtBG,EAAa,CAAEC,wBAGZ,GAHmBC,gBAMZC,UACNL,EAAWK,GAAK,GAPUC,aAUvBD,UACJL,EAAWK,UAYI,CACtBE,iBANeF,SACM,iBAAVJ,EAJJD,EAAWQ,OAAOP,GAKlBC,EAAWD,GAAOI,cChBbI,EAAQV,OACdI,EAAuBJ,QAAhBW,EAAgBX,QAATY,EAASZ,OACvBa,EAAaF,MAARG,EAAQH,MAEfI,EAAcJ,EADPC,EAAO,OAAS,aAEzBI,EAAUD,EAAYX,YAEjBa,WACAD,WAGAE,EAAIZ,UACXU,EAAUD,EAAYT,GACfa,MAgBHA,EAAgB,CACpBC,aAdOA,EAAId,MACD,IAANA,EAAS,KACLe,EAAOf,EAAIgB,KAAKC,IAAIjB,UAC1BY,EAAID,IAAQI,GACLD,EAAId,GAAY,EAARe,UAEVF,GASPK,wBALOd,EAAQ,CAAEN,MAAOa,IAAON,QAAOC,UAMtCK,MACAH,MACAD,MACAK,cAEKC,WC5COM,EAASC,OACnBC,EAASD,WA0BJE,EAAOtB,UACdqB,GAAUrB,EACHa,WAQAU,EAAWvB,SACE,iBAANA,EAAiBA,EAAIA,EAAEW,UAGjCE,EAAiB,CACrBC,aA9BWd,UACXqB,GAAUE,EAAWvB,GACda,GA6BPS,SACAX,sBAxCOU,GAyCPG,kBAvBgBxB,UAChBqB,GAAUrB,EACHa,GAsBPY,4BAbe,IAAXJ,GAAcC,EAAOD,GAClBR,GAaPD,aAxCWZ,UACXqB,EAASE,EAAWvB,GACba,GAuCPa,kBA/BgB1B,UAChBqB,GAAUE,EAAWvB,GACda,WA+BFA,WCrDOc,EAAUP,OAClBQ,EAAYT,EAASM,EAAUL,aAG5BK,EAAUzB,UACJ,IAANA,EAAU,EAAIA,EAAIgB,KAAKC,IAAIjB,OAS9Ba,EAAkB,CACtBF,IAbciB,MAcdhB,aARWiB,OACLC,EAAIL,EAAUI,EAAElB,cACZ,IAANmB,GAASF,EAAUhB,IAAIkB,GACpBjB,WAOFA,WCXOkB,QACVC,EAA4B,OAoB1BnB,EAAmB,CACvBC,aAlBAmB,EACAC,EACAC,EACAC,uBAAAA,MAEAH,EAAKI,iBAAiBH,EAAMC,EAASC,GACrCJ,EAAUM,MAAK,kBACNL,EAAKM,oBAAoBL,EAAMC,EAASC,MAE1CvB,GAUP2B,4BANAR,EAAYA,EAAUS,QAAO,SAAAC,UAAUA,OAChC7B,WAOFA,WCpBO8B,EAAMjD,OACZa,EAAab,MAARc,EAAQd,MACfkD,EAAa,CAAErC,IAAKC,EAAKA,IAAKD,GAC9BsC,EAAkB,CAAEtC,MAAKC,OACzBsC,EAAS9B,KAAKC,IAAIV,EAAMC,YAErBuC,EAAW/C,UACXA,EAAIO,WAGJyC,EAAWhD,UACXA,EAAIQ,WAOJyC,EAAajD,UAChB+C,EAAW/C,GAAW,MACtBgD,EAAWhD,GAAW,MACnB,SAoBW,CAClBkD,mBANiBlD,OACXmD,EAAQF,EAAajD,UACpBmD,EAAQN,EAAgBM,GAASnD,GAKxC8C,SACAxC,cAbYN,OACNmD,EAAQF,EAAajD,UACpBmD,EAAQP,EAAWO,GAASnD,GAYnCQ,MACAD,MACA6C,oBAjCkBpD,UACX+C,EAAW/C,IAAMgD,EAAWhD,IAiCnCgD,aACAD,aACAM,sBA1BoBrD,MAChBO,IAAQC,EAAK,OAAOR,OACjB+C,EAAW/C,IAAIA,GAAK8C,OACpBE,EAAWhD,IAAIA,GAAK8C,SACpB9C,aCTKsD,EAAY5D,OAClB6D,EAAkD7D,SAA1C8D,EAA0C9D,aAA9B+D,EAA8B/D,WAApBgE,EAAoBhE,YAATiE,EAASjE,OAClDkE,EAAkDlE,UAAzCmE,EAAyCnE,cAA5BoE,EAA4BpE,WAAlBqE,EAAkBrE,SAAVW,EAAUX,QAC1CsE,EAAiCL,SAAdM,EAAcN,QAC3CO,EAAa,CAAC,QAAS,SAAU,YACjCC,EAAchD,EAAS,GACvBiD,EAAajD,EAAS,GACtBkD,EAAiBlD,EAAS,GAC1BmD,EAAmBvC,IACnBwC,EAAoBxC,IACpByC,EAAyBF,EAAiB9B,UAC1CiC,EAA0BF,EAAkB/B,UAC5CkC,EAAiB,CAAEC,MAAO,IAAKC,MAAO,KACtCC,EAAiB,CAAEF,MAAO,EAAGC,MAAO,GACpCE,EAAYrB,EAAW,EAAI,GAE3BsB,EAAYpC,EAAM,CACtBpC,IAAKF,EAAME,IAAM,GACjBC,IAAKH,EAAMG,IAAM,KAGfwE,GAAgB,EAChBC,GAAgB,EAChBC,GAAe,EACfC,GAAU,WA2DLC,EAAKC,QACZF,EAAuB,cAAbE,EAAInD,OACgC,IAA9BmD,EAAmBC,YAtChBrD,EACbsD,EAuCAC,EAAWC,EAAMlC,EAAO5C,MAAOmD,EAASnD,QAAU,EAClD+E,EAAoBP,IAAYK,EAChCG,GA1Ca1D,EA0CiBoD,EAAI9B,OAzClCgC,EAAOtD,EAAK2D,UAAY,KACvB1B,EAAW2B,QAAQN,IAAS,IAyC7BO,EAAiBN,GAAaL,GAAWQ,EAE/CX,GAAgB,EAChBnB,EAAYkC,YAAYV,GACxBhB,EAAezD,IAAI2C,GACnBA,EAAO3C,IAAIkD,GACXN,EAAWwC,iBAAiBC,SAAS,mBAzD/BhE,EAAQkD,EAAoBe,SAAVtC,EACxBW,EACGzD,IAAImB,EAAM,YAAakE,GACvBrF,IAAImB,EAAM,WAAYmE,GACtBtF,IAAImB,EAAM,YAAakE,GACvBrF,IAAImB,EAAM,UAAWmE,GAqDxBC,GACAlC,EAAYvD,IAAIiD,EAAYyC,UAAUjB,EAAKrB,IAC3CI,EAAWxD,IAAIiD,EAAYyC,UAAUjB,EAAKpB,IAC1CF,EAAOwC,KAAK,eAERb,IAAmBR,GAAe,GAClCY,GAAgBT,EAAIS,2BAGjBK,EAAKd,OACPJ,IAAkBE,EAAS,KACxBqB,EAAa3C,EAAYyC,UAAUjB,EAAKrB,GAAYrD,MACpD8F,EAAY5C,EAAYyC,UAAUjB,EAAKpB,GAAWtD,MAClD+F,EAAajB,EAAMe,EAAYrC,EAAYxD,OAC3CgG,EAAYlB,EAAMgB,EAAWrC,EAAWzD,YAC9CsE,EAAgByB,EAAaC,KACNzB,EAAc,OAAOkB,QAExCQ,EAAO/C,EAAYgD,YAAYxB,GAC/ByB,EAAezG,EAAM+C,WAAWU,EAASnD,OACzCoG,GAAUrH,EAAOY,MAAQwG,EAAe,EAAI,GAE7C5B,GAAgB0B,IAAM1B,GAAe,GAC1CxB,EAAU5D,QACVyD,EAAOzC,IAAI8F,EAAOG,GAClB1B,EAAIS,0BAGGM,QAnEYY,EAAgBC,EAC7BL,EAmEEM,EAAaxH,WACfyH,EAAWtD,EAAYuD,aA1Ef3D,EAAWoB,EAAiBH,GAC7BS,EAAU,QAAU,SA0E3BkC,WA/DcA,OACZC,EAAwB5H,eAAV6H,EAAU7H,QAG1B8H,IAFkBF,EAAaG,WAAW,GAAG,GACbF,QAAUA,EAAM5G,QACnBK,KAAKC,IAAIoG,GAtDxB,EAuDdK,EAAcL,EAAQvD,EAASnD,SAEjC6G,IAAa/D,IAAapD,EAAM+C,WAAWsE,GAAc,KACrDC,EAAOJ,EAAMrG,QAAQJ,KAA8B,EAA1Ba,EAAU0F,GAAO1G,cACzC2G,EAAaM,QAAQD,EAAKhH,MAAO,GAAGkH,aAExCnI,EAAOY,MAAQyE,EAAU3B,WAAWsE,GAAc,KAC/CI,EAAO/C,EAAU/B,WAAW0E,GAAe,MAAQ,aAClD3C,EAAU+C,GAAQvE,EAAO5C,aAE3B2G,EAAaG,WAAWJ,GAAQ5D,GAAUoE,SAgDnCE,CAAaZ,GACrBa,GAvEahB,EAuEQG,EAvEQF,EAuEEI,EAtE/BT,EAAOnB,EAAMzE,KAAKC,IAAI+F,GAAShG,KAAKC,IAAIgG,IAC1CjG,KAAKC,IAAI+F,IAAWhG,KAAKC,IAAIgG,IAClB,IAAXD,GAA2B,IAAXC,EAD6B,EAE1CjG,KAAKC,IAAI2F,EAAOI,IAoENvB,EAAMlC,EAAO5C,MAAO0D,EAAe1D,QAAU,KAE7CwE,IAASD,GAAe,GACzCD,GAAgB,EAChBD,GAAgB,EAChBT,EAAkB/B,YAClBgB,EAAWyC,SAASnB,EAAYA,EAAYkD,GAC5Cd,EAASW,SAASR,GAAQ5D,GAC1B0B,GAAU,EACVpB,EAAOwC,KAAK,sBAGLd,EAAMwC,EAAgBC,UACtBlH,KAAKC,IAAIgH,EAASC,YAGlBC,EAAM9C,GACTH,GAAcG,EAAIS,uBAWE,CACxBsC,mCApIMnG,EAAO2B,EACbU,EACGxD,IAAImB,EAAM,aAAa,eACvBnB,IAAImB,EAAM,YAAY,eACtBnB,IAAImB,EAAM,aAAcmD,GACxBtE,IAAImB,EAAM,YAAamD,GACvBtE,IAAImB,EAAM,cAAemE,GACzBtF,IAAImB,EAAM,cAAemE,GACzBtF,IAAImB,EAAM,QAASkG,IA6HtBE,+BATQnD,GAURa,8BANOf,GAOPR,yBACAC,oCCzLY6D,EAAY5I,OAClBiE,EAAsBjE,OAAhB6I,EAAgB7I,cACdsE,EAAeL,SACzB6E,EAAS,CAAEC,EAAG,UAAWC,EAAG,WAC5BC,EAAYxH,EAAS,GACrByH,EAAWzH,EAAS,GACpB0H,EAAW1H,EAAS,GACpB2H,EAAa3H,EAAS,GAIxB4H,EAAwB,GACxBC,GAAe,IAAIC,MAAOC,UAC1B/D,GAAU,WAELmB,EAAUjB,EAAUnD,GAC3BiD,GAAWE,EAAI8D,YACTC,EAAIZ,EAAOtG,GACXd,EAAQ+D,EAAUE,EAAI+D,GAAK/D,EAAI8D,QAAQ,GAAGC,UACzCN,EAAWlI,IAAIQ,SAyCE,CACxB2E,qBAvCmBV,OACbgE,EAAQ/C,EAAUjB,EAAKrB,UAC7B2E,EAAU/H,IAAIyI,GACdR,EAASjI,IAAIyI,GACNd,EAAYrI,QAAQyI,EAAUhI,QAoCrCkG,qBAjCmBxB,OACbgE,EAAQ/C,EAAUjB,EAAKrB,GACvBsF,GAAU,IAAIL,MAAOC,UACrBK,EAAWD,EAAUN,SAEvBO,GA1BgB,KA2BdA,GAzBU,MAyBaR,EAAc,IACzCA,EAAYzG,KAAK+G,EAAM1I,OACvBqI,EAAeM,GAGjBV,EAAShI,IAAIyI,GAAO3H,SAASmH,GAC7BA,EAASjI,IAAIyI,GACNd,EAAYrI,QAAQ0I,EAASjI,QAqBpCyG,yBAhBMmC,GADU,IAAIN,MAAOC,UACAF,EACrBQ,EAAeX,EAASlI,MAExB0G,EAAQ0B,EACXU,OA1Ce,GA2CfC,KAAI,SAAAC,UAAcH,EAAeG,KACjCC,MAAK,SAACC,EAAIC,UAAQ9I,KAAKC,IAAI4I,GAAM7I,KAAKC,IAAI6I,GAAM,GAAK,KAAI,UAE5DjB,EAASjI,IAAI2I,EA7CG,MA6CsBlC,EAAQ,EAAIA,GAClD0B,EAAc,GACPR,EAAYrI,QAAQ2I,EAASlI,QAOpC2F,sBCnDYyD,EACdC,OAEMC,EAAMjJ,KAAKiJ,IAAI,GAAID,UAClB,SAAChK,UAAcgB,KAAKkJ,MAAMlK,EAAIiK,GAAOA,YAc9BE,EAAuBC,UAC9BC,OAAOC,KAAKF,GAAOV,IAAIvJ,iBAGhBoK,EACdtI,EACAuI,OAEMC,EAAKxI,EAAKyI,UACZD,EAAGE,SAASH,IAAYC,EAAG/H,OAAO8H,YAGxBI,EAAS3I,EAAmBuI,OACpCC,EAAKxI,EAAKyI,UACXD,EAAGE,SAASH,IAAYC,EAAG3J,IAAI0J,YCvCtBK,EAAWnL,OACjBoE,EAA0BpE,WAAhBoL,EAAgBpL,QAATqL,EAASrL,OAC5BsL,EAAqBjB,EAAgB,GACrCkB,EAAW9J,EAAS,GACpB+J,EAAe/J,EAAS,GACxBgK,EAAahK,EAAS,GACtBS,EAAYD,EAAU,GACtByJ,EAAQ,CAAEN,QAAOC,iBAkCd9E,EAASjG,UAChBoL,EAAMN,MAAQ9K,EACPa,WAQAwK,EAAQrL,UACfoL,EAAML,KAAO/K,EACNa,MAQHA,EAAmB,CACvBe,YACAkC,WACAwH,cA5CYzJ,GACZsJ,EAAWvK,IAAIiB,GAAGH,SAASoC,OD1C7B1C,EACAmK,EACAC,EACAC,EACAC,ECuCQC,EAAYR,EAAWxK,MACvBiL,GD5CRxK,EC4CgBuK,ED3ChBJ,EC2C2B,ED1C3BC,EC0C8B,IDzC9BC,ECyCmC,EDxCnCC,ECwCsCN,EAAMN,MDrC1CW,GAA8BrK,EAAQmK,IAAWC,EAAQD,IAA/CG,EAAQD,WCsClB7J,EAAUhB,IAAIuK,GACdA,EACG1J,YACAD,SAASoK,GACTlK,SAASuJ,YAbMpJ,GAClBA,EAAEP,OAAO8J,EAAML,MACfG,EAAapK,IAAIe,GAYjBgK,CAAWV,GACJtK,GAmCPiL,gBAhCcjK,OACR+E,EAAO/E,EAAElB,MAAQmD,EAASnD,MAE1BoL,GADcf,EAAmBpE,UAEnCmF,GAAYjI,EAASlD,IAAIiB,GACtBkK,GA4BPC,kBAxDAf,EAASnK,IAAIoK,GACbpH,EAAShD,IAAImK,GACbC,EAAa1J,SAAS,IAuDtBwE,iCAVAqF,EAAQN,GACDlK,GAUPoL,kCArBAhG,EAAS6E,GACFjK,GAqBPwK,UACApF,mBAEKpF,WC7EOqL,EAAaxM,OACnBW,EAA2CX,QAApCoE,EAAoCpE,WAA1B8D,EAA0B9D,aAAdgE,EAAchE,YAC3Ca,EAAqCF,MAAhCG,EAAgCH,MAA3B0C,EAA2B1C,aAAf2C,EAAe3C,aAEzC8L,GAAW,EACXC,EAAU,QAyBa,CACzBlJ,mBAjBiBrB,aAPMA,UACnBsK,IAAYC,IACZrJ,EAAWe,EAASnD,OAAekB,EAAElB,QAAUJ,IAC/CyC,EAAWc,EAASnD,QAAekB,EAAElB,QAAUH,IAK9C6L,CAAgBxK,KAErBuK,EAAUE,OAAOC,YAAW,eACpBC,EAAanM,EAAM6C,UAAUrB,EAAElB,OACrCkB,EAAEjB,IAAI4L,GACNhJ,EAAWyC,SAAS,IAAIoF,QAAQ,GAChC3H,EAAU5D,QACVsM,EAAU,IAnBI,MA6BhBK,sBANoBC,GACpBP,GAAYO,aC7BAC,EAAcjN,OACpBkN,EAAqClN,YAA1BmN,EAA0BnN,cAAbC,EAAaD,WACvCoN,EAAenK,EAAM,CAAEpC,KAAMsM,EAAclN,EAAUa,IAAK,IAC1DuM,EAAoB,CAACH,EAAU1M,QAAQ2M,IACvCG,EAAqBH,EAAclN,QAmBb,CAC1BO,iBAVe+M,EAAuBC,OAChCC,EAAiBF,EAAYvD,IAAIoD,EAAa5J,WAC9CkK,WAVgBH,OAChBI,EAAYJ,EAAY,GACxBK,EAAUL,EAAYA,EAAYnK,OAAS,UAG1CH,EAAM,CAAEpC,IAFH0M,EAAYM,YAAYF,GAAa,EAE7B7M,IADRyM,EAAYpH,QAAQyH,KAMXE,CAAeL,GAA5B5M,QAAKC,eAERwM,EACAE,EACEC,EAAe1D,MAAMlJ,EAAM,EAAGC,EAAM,GADzB2M,EADcJ,aClBpBU,EAAa/N,OACnBmN,EAA8CnN,cAAjCoE,EAAiCpE,WAAvBW,EAAuBX,QAAhB6I,EAAgB7I,cAGhD0N,EAA6BzK,EAAM,CAAEpC,IAF/BF,EAAME,IAAMgI,EAAYrI,QAAQ,IAEIM,IADpCH,EAAMG,IAAM+H,EAAYrI,QAAQ,MACpC6C,eAAYC,qBAeO,CACzB1C,cARYoN,EAAqB9L,eANfA,UACA,IAAdA,EAAwBoB,EAAWc,EAASnD,QAC7B,IAAfiB,GAAyBmB,EAAWe,EAASnD,OAK5CgN,CAAW/L,QAEVgM,EAAef,IAA4B,EAAbjL,GACpC8L,EAAQG,SAAQ,SAAAhM,UAAKA,EAAEf,IAAI8M,kBCPfE,EAAapO,OACnBY,EAA0CZ,OAApCW,EAAoCX,QAA7BuN,EAA6BvN,cAAhBmN,EAAgBnN,cAC1CsD,EAAyC3C,aAA7B+C,EAA6B/C,aAAjBgD,EAAiBhD,wBAExC0N,EAAYC,EAAYC,UACxBjN,KAAKC,IAAI+M,GAAMhN,KAAKC,IAAIgN,GAAMD,EAAKC,WAenCC,EAAS3K,EAAgB3B,OAC1BuM,EAAK5K,EACL6K,EAAK7K,EAASsJ,EACdwB,EAAK9K,EAASsJ,MAEfvM,EAAM,OAAO6N,MACbvM,EAAW,OAAOmM,EAAYA,EAAYI,EAAIC,GAAKC,OAElDC,EAAWP,EAAYI,EAAkB,IAAdvM,EAAkBwM,EAAKC,UACjDrN,KAAKC,IAAIqN,GAAY1M,QA+BH,CACzB6F,oBAfkBI,EAAkB0G,OAC9BhL,EAAS7D,EAAO6D,OAAO5C,MAAQkH,EAC/B2G,WAxCgBjL,OAChBsE,EAAWxE,EAAaE,SAQvB,CAAEgE,MAPe0F,EACrBvD,KAAI,SAAA+E,UAAcA,EAAa5G,KAC/B6B,KAAI,SAAAgF,UAAcR,EAASQ,EAAY,MACvChF,KAAI,SAAC9C,EAAM+H,SAAO,CAAE/H,OAAMW,MAAOoH,MACjC/E,MAAK,SAACoE,EAAIC,UAAOjN,KAAKC,IAAI+M,EAAGpH,MAAQ5F,KAAKC,IAAIgN,EAAGrH,SAElB,SAClBiB,YA+BG+G,CAAerL,GAC5BgE,WAjBiBhE,EAAgBgE,SACjBjH,GAAQ8C,EAAWG,IACtB,OAAOgE,MAEpB6F,EAAe1N,EAAO6H,MAApBhH,QAAKC,eACNwC,EAAWO,GAAUhD,EAAMC,EAYpBqO,CAAgBtL,EAAQiL,EAAWjH,OAC3CuH,GAAgBxO,GAAQ8C,EAAWG,UAEpCgL,GAAQO,EAAqB,CAAEvH,QAAOM,YAKpC,CAAEN,QAAOM,SAFKA,EAAWqG,EADbjB,EAAY1F,GAASiH,EAAW3G,SACE,KAOrDD,iBAtBeL,EAAe3F,SAGvB,CAAE2F,QAAOM,SADCqG,EADEjB,EAAY1F,GAAS7H,EAAO6D,OAAO5C,MAChBiB,KAqBtCsM,qBC5DYa,EAAYrP,OAuElBsP,EACAC,EACAnP,EAxEA6D,EAAsCjE,OAAtBwP,EAAsBxP,WACtCmN,EAAmDnN,cAAtCC,EAAsCD,WAA5ByP,EAA4BzP,aAAhBuN,EAAgBvN,cACrD0P,EAAWjF,EAAUgF,GACrBE,EAAYlF,EAAUgF,GAAYG,UAClCC,GAkEEP,EAAM/B,EAAY,GAAK,EACvBgC,EAAUO,EAAYR,EAAKK,GAC3BvP,EAAQ2P,EAAUT,EAAKC,EAAS,GAC/BS,EAAcT,EAASnP,EAAO,IArEN6P,sBA0EzBV,EAAUO,EADJ7P,EAAWsN,EAAY,GAAK,EACPmC,GAC3BtP,EAAQ2P,EAAU5C,EAAauC,GAAWzP,UACzC+P,EAAcT,GAAUnP,EAAO,GA5EA8P,IAClCC,EAA4B,MAAhBlM,EAAKmM,OAAiB,OAAS,eAExCC,EACPd,EACAe,UAEOf,EAAQgB,QAAO,SAACC,EAAWvB,UAEzBuB,EADMf,EAAWR,KAEvBqB,YAGIR,EACPW,EACAlB,UAEOA,EAAQgB,QAAO,SAACC,EAAavB,UAClBoB,EAAkBG,EAAGC,GACpB,EAAID,EAAEP,OAAO,CAAChB,IAAMuB,IACpC,aAGIT,EACPU,EACAlB,EACAe,UAEOf,EAAQgB,QAAO,SAACC,EAAWvB,OAC1ByB,EAAYF,EAAIf,EAAWR,UAC1ByB,EAAYD,EAAYC,EAAYF,IAC1CF,YAeIN,EACPT,EACAe,EACApO,OAEMyO,EAAapB,EAAQxF,QAAQG,MAAK,SAACsG,EAAGI,UAAMJ,EAAII,YAC/CD,EAAW3G,KAChB,SAACnC,EAAOgJ,OACAC,EAAU3D,GAAgBjL,GAAiB,EAAL,GACtC6O,EAAS5D,GAAgBjL,EAAgB,EAAJ,GAErCyH,WAtBV4F,EACAe,EACApO,OAEM8O,EAAatB,EAAStM,OAAS,SAC9BiN,EACLd,EAAQvF,KAAI,SAAAiF,UAAMA,EAAI/M,GAAa8O,KACnCV,GAegBW,CADON,EAAW5G,MAAM,EAAG8G,GACAP,EAAMpO,SAGxC,CAAEyH,QAAOuH,UAFE,SAAC9M,UACjBA,EAAWuF,EAAQmH,EAAUC,GACJlJ,QAAOzD,UAAW,YA2CzB,CACxB+M,0BAxBOtB,EAAWuB,OAAM,SAAC1D,OAAE7F,iBAElBwI,EADcX,EAAS3M,QAAO,SAAAkM,UAAKA,IAAMpH,KACT5H,IAAa,MAuBtDoR,eARaC,GACbzB,EAAW1B,SAAQ,SAACT,OAAE7F,UACpByJ,EAAOzJ,GAAO0J,MAAMpB,GAAa,OAOnCvP,cApBY0Q,GACZzB,EAAW1B,SAAQ,SAAAqD,OACTN,EAA+BM,YAApBpN,EAAoBoN,WAAV3J,EAAU2J,QACjC3N,EAASqN,EAAU1B,EAAkBvO,OACvC4C,IAAWO,IACbkN,EAAOzJ,GAAO0J,MAAMpB,GAAgBtM,MACpC2N,EAAUpN,SAAWP,OAezBgM,uBCvHY4B,EAAazR,OACnBmN,EAAsCnN,cAAzByP,EAAyBzP,aAAbC,EAAaD,WACtC0R,EAA0B1R,kBAATY,EAASZ,OAC5B2R,EAAalC,EAAWzF,KAAI,SAAA4H,UAAKA,EAAIF,KACrCnE,EAAc9C,EAAUgF,GAAYzF,cAGtBnC,UACL4H,EAAW1F,MAAM,EAAGlC,GACrB0I,QAAO,SAACC,EAAGoB,UAAMpB,EAAIoB,IAAG,MAJhCC,GAQYjR,EAAO,CAAC,EAAGuM,GAAcA,GAAe,CAAC,IAC1CnD,IAAI8H,GAAavB,QAAO,SAACC,EAAGI,UAAMJ,EAAEP,OAAOW,KAAI,aAGvDkB,EAAYf,UACZxD,EAAYvD,KAAI,SAAC6E,EAAMhH,SAAW,CACvCzH,MAAOyO,EAAOY,EAAW5H,GAAS8J,EAAW9J,GAASkJ,EACtDxQ,IAAKsO,EAAO5O,EAAW0R,EAAW9J,GAASkJ,EAC3ClJ,kBAauB,CACzBkK,eAVa3N,UACNyN,EAActB,QAAO,SAACyB,EAAgBrI,OACnC9B,EAAsB8B,QAAfvJ,EAAeuJ,QAARpJ,EAAQoJ,eACU,IAAzBqI,EAAK7L,QAAQ0B,MACbzH,EAAQgE,GAAY7D,EAAM6D,GACd4N,EAAK/B,OAAO,CAACpI,IAAUmK,IACjD,eCpCSC,EAAUjS,OAChBiE,EAAoBjE,OAAdkS,EAAclS,YAEtBmS,EADa,CAAEpJ,WAOVzI,SACF,eAAeA,gBARA0I,WAWb1I,SACF,mBAAmBA,aAXK2D,EAAKmM,QAChC9E,EAAqBjB,EAAgB,GACrC+H,EAAiBF,EAAUX,MAC7B9E,GAAW,EACXrI,EAAW,QA8BS,CACtBiN,iBALAe,EAAeC,UAAY,GAC3BjO,EAAW,GAKXkO,YAtBUnQ,OACNsK,OACE5I,EAASyH,EAAmBnJ,EAAElB,OAEhCmD,IAAaP,IACf0O,iBAAiBL,GAAWG,UAC5BD,EAAeC,UAAYF,EAActO,GACzCO,EAAWP,KAgBbkJ,sBAZoBC,GACpBP,GAAYO,aCKAwF,EACdC,EACAP,EACAZ,EACA5O,EACA2B,OCjD0BqO,ECKG1S,EACvB0N,EAAE5M,EAAa6R,EF+CnBzS,EASEwC,QARI4B,EAQJ5B,OAPFkQ,EAOElQ,aANFgP,EAMEhP,kBALF9B,EAKE8B,OAJF0I,EAIE1I,QAHFqB,EAGErB,WAFFmQ,EAEEnQ,iBADFoQ,EACEpQ,gBAGEuB,WG9DaA,OACbmM,EAAkB,MAATnM,EAAe,IAAM,UAQjB,CACjB8O,MARqB,MAAT9O,EAAe,IAAM,IASjCzD,iBAPe+B,OACTmL,EAAoBnL,EAAKyQ,wBAAvBC,UAAOC,iBACG,MAAX9C,EAAiB6C,EAAQC,GAMhC9C,UHkDW+C,CAAK7O,GACZuE,GClEoB6J,EDkEMzO,EAAKzD,QAAQ0R,GC3DnB,CACxB1R,iBALeF,UACPA,EAAIoS,EAHO,KAQnBU,aARmB,MDkEfnT,EAAW4I,EAAYuK,aACvB3D,EAAa6B,EAAOtH,IAAI/F,EAAKzD,SAASwJ,IAAInB,EAAYrI,SAEtD6S,WTtCN3I,EACA4I,WAEMC,EAAS,GACNtE,EAAI,EAAGA,EAAIvE,EAAMtH,OAAQ6L,GAAKqE,EACrCC,EAAO3Q,KAAK8H,EAAMX,MAAMkF,EAAGA,EAAIqE,WAE1BC,ES8BcC,CAAW/D,EAAYoD,GACb7I,KAAI,SAAAyJ,UAAKA,EAAElD,QAAO,SAACC,EAAGoB,UAAMpB,EAAIoB,QACzD8B,EAAcjJ,EAAU4I,GACxBlG,EAAcsC,EAAWc,QAAO,SAACC,EAAGoB,UAAMpB,EAAIoB,IAAG,GACjD1E,EAAYnN,EAAU,CAAEG,QAAOD,aAC/B8O,WIjEmB/O,OAOjBgB,EANAqS,EAA+BrT,YAApBkN,EAAoBlN,YAATY,EAASZ,OACjC2T,EAAaN,EAAUrJ,IAAIkD,EAAU1M,SACrCoT,GAIE5S,EAAUN,EAAQ,CAAEC,MADZsC,EAAM,CAAEpC,IAAK,EAAGC,IAAKuS,EAAUjQ,OAAS,IACrBhD,MAAO,EAAGQ,SAEpCyS,EAAUrJ,KAAI,SAACsJ,EAAMzL,OACpBI,EAAOjH,EAAQE,IAAI2G,EAAQ,GAAG5G,aAC7BqS,EAAOK,EAAW9L,GAAS8L,EAAW1L,aASxB,CACvBzH,iBANeqH,UACD+L,EAAiB7J,MAAM,EAAGlC,GAC3B0I,QAAO,SAACC,EAAGoB,UAAMpB,EAAIoB,IAAG+B,EAAW,MJgD/BE,CAAW,CAAER,YAAWnG,YAAWtM,SAChDkT,EAAeJ,EAAY1J,IAAI+E,EAAWvO,SAC1CuT,EAAU9G,EAAc,CAAEC,YAAWC,cAAalN,aAClD+T,GAAiBpT,GAA0B,KAAlBkS,EACzBmB,EAA8B,cAAlBnB,EACZrF,EAAiBsG,EAAQvT,QAAQsT,EAAcG,GAC/C1G,EAAcyG,EAAgBvG,EAAiBqG,EAK/CjM,EAAQnH,EAAQ,CAAEC,MADNsC,EAAM,CAAEpC,IAAK,EAAGC,IADjBQ,KAAKR,IAAI,EAAGyM,EAAYnK,OAAS,KAERhD,MAAOwS,EAAYhS,SACvDsT,EAAgBrM,EAAMrG,QAItBb,WKpFoBX,OAClBmN,EAAsBnN,cAATY,EAASZ,aAUJ,CACxBQ,iBATe+M,OACTI,EAAYJ,EAAY,GACxBK,EAAUL,EAAYA,EAAYnK,OAAS,UAG1CH,EAAM,CAAEpC,IAFHD,EAAO+M,EAAYR,EAAcS,EAEzB9M,IADR6M,ML4EMwG,CAAY,CAAEvT,OAAMuM,gBACd3M,QAAQ+M,GA0B5BvJ,WMjHkBoQ,OAGpBC,EAAiB,WAEZC,EAAYtH,EAAiBuH,UAC7B,WACDvH,MAAaqH,GAAgBE,cAI5BnU,IACPiU,EAAiBzH,OAAO4H,sBAAsBJ,SAQxB,CACtBK,QAASH,GAAY,EAAMlU,GAC3BA,MAAOkU,GAAY,EAAOlU,GAC1BsU,KAAMJ,GAAY,cAPlB1H,OAAO+H,qBAAqBN,GAC5BA,EAAiB,MNgGDO,EAvBH,WACbC,GAAO/Q,WAAW8H,KAAK/H,IAAQyI,aACzBwI,EAAUD,GAAO/Q,WAAWsI,OAAOvI,OAEpCkR,GAAY1O,gBACVzF,GAAMiU,GAAOzH,aAAa5J,UAAUK,IACrCiR,IACFD,GAAO7Q,UAAU0Q,OACjBrQ,EAAOwC,KAAK,YAGZjG,EAAM,KACFsB,EAAY2S,GAAO/Q,WAAW5B,UAAUjB,MAC9C4T,GAAOG,aAAapU,KAAKqU,GAAa/S,GACtC2S,GAAOK,YAAYtU,KAAK0Q,GAGrBwD,GAASzQ,EAAOwC,KAAK,UAC1BgO,GAAOM,UAAU7C,GAAGuC,GAAO/Q,WAAWM,UACtCyQ,GAAO7Q,UAAUyQ,aAKbW,EAAgB7H,EAAY1F,EAAM5G,OAClCmD,GAAW3C,EAAS2T,GACpBvR,GAASpC,EAAS2T,GAClBH,GAAc,CAAC7Q,GAAUP,IACzBC,GAAaqH,EAAW,CAAE/G,YAAUgH,QAAOC,KAAM,IACjDzD,GAAewG,EAAa,CAChCjB,cACAtF,QACAlH,QACAC,OACA2M,cACA1J,YAEI2D,YOnHiBxH,OACRqV,EAA0CrV,QAA5B4H,EAA4B5H,eAAdgE,EAAchE,YACjDkU,EAAkDlU,gBAAnCqE,EAAmCrE,SAAnBsV,EAAmBtV,kBAEjDwH,EAAS3D,OACV0R,EAAe1R,EAAOsE,SACtBqN,EAAY3R,EAAOgE,QAAUwN,EAAapU,MAE5CsU,IACFvR,EAAU5D,QACVkV,EAAelU,IAAImU,IAEjBC,IACFtB,EAAchT,IAAImU,EAAapU,OAC/BoU,EAAanU,IAAI2C,EAAOgE,OACxBxD,EAAOwC,KAAK,iBAeO,CACrBsB,kBAZgB7H,EAAWuO,GAE3BrH,EADeI,EAAaG,WAAWzH,EAAGuO,KAY1ChH,eARavH,EAAW4B,OAClBuT,EAAcJ,EAAa7T,QAAQN,IAAIZ,GAE7CkH,EADeI,EAAaM,QAAQuN,EAAYxU,MAAOiB,MPyFxCwT,CAAS,CACxB1R,YACAK,SACAwD,QACAqM,gBACAtM,gBACA/D,YAIIkR,GAAcnR,EAAY,CAC9BI,YACAC,OACAF,WACAI,YAAayE,EAAY,CACvB3E,OACA4E,gBAEF3E,QAASuO,EACTpO,SACAwD,QACAlH,QACAyD,YACAxD,OACAkD,cACA0D,YACAI,gBACA/D,YAIIgR,GAAiB,CACrB7Q,YACAC,OACA8Q,eACAlM,cACAhB,QACAqM,gBACAvT,QACAyD,YACA1B,UACAoB,cACAsJ,aAAcZ,EAAa,CACzBxI,YACArD,QACAyD,YACAN,gBAEFkR,aAAcjH,EAAa,CACzBZ,cACAxM,QACAyD,YACAyE,gBAEF8M,gBEnL2B3V,EFmLI,CAC7BW,SEnLE+M,EAAgC1N,EAAOW,MAArCG,QAAa6R,WAOQ,CAC3B1R,aANWX,UACaA,EAAIQ,IACF6R,KFiL1BpF,cACA3F,gBACAJ,YACA0N,YAAa7F,EAAY,CACvBpL,OACAkJ,cACA/I,YACAmJ,cACAkC,aACAxP,aAEF2V,aAAcnE,EAAa,CACzBtE,cACAuE,kBACA9Q,OACA6O,aACAxP,aAEFyT,cACA7P,UACAsR,UAAWlD,EAAU,CACnBhO,OACAiO,sBAGG2C,GQpMF,IAAMgB,EAA0B,CACrC3V,MAAO,SACP+D,KAAM,IACN6O,cAAe,GACfgD,kBAAmB,IACnB/R,UAAU,EACVgS,WAAW,EACXC,eAAgB,eAChBC,cAAe,cACfvE,gBAAiB,EACjB9Q,MAAM,EACNsV,cAAe,cACfrD,eAAgB,EAChBzH,MAAO,GACPwH,WAAY,UCFd,SACEuD,EACAC,gBAAAA,UlBhBAhC,EACAiC,EAEM3J,EkBqBFmI,EAIA3C,EACAZ,EAXEjN,iBChBA/B,EAAuB,CAC3BgU,QAAS,GACTjQ,YAAa,GACbqB,UAAW,GACX6O,KAAM,GACNC,OAAQ,GACRC,OAAQ,GACRrG,OAAQ,GACRsG,OAAQ,GACRtK,OAAQ,IAkBJjL,EAAqB,CACzB0F,cAhBYlB,UACZrD,EAAUqD,GAAKwI,SAAQ,SAAAwI,UAAKA,EAAEhR,MACvBxE,GAePyV,aAPWjR,EAAiB4O,UAC5BjS,EAAUqD,GAAOrD,EAAUqD,GAAK5C,QAAO,SAAA4T,UAAKA,IAAMpC,KAC3CpT,GAMP0V,YAbUlR,EAAiB4O,UAC3BjS,EAAUqD,GAAOrD,EAAUqD,GAAKsK,OAAO,CAACsE,IACjCpT,WAaFA,EDhBQ2V,GACTC,EAAa1U,IACb2U,GlBpBN5C,iBkByJQ6C,EAAqBpC,EAAO5Q,KAAKzD,QAAQ2V,GAC3Ce,IAAoBD,GAAoBE,IAC5C9S,EAAOwC,KAAK,WlB1JdwP,EkBmByC,IlBjBnC3J,EAAU,CAAE0K,GAAI,GACf,WACLxK,OAAOyK,aAAa3K,EAAQ0K,IAC5B1K,EAAQ0K,GAAKxK,OAAOC,WAAWuH,EAAUiC,IAAS,IkBe9CG,EAASW,EACPN,EAAYxS,KAARuS,EAAQvS,MAGhBiT,GAAY,EACZ5U,EAAU6U,EAAc,GAAI1B,GAC5BqB,EAAkB,WAMbM,QACFrB,EAAY,MAAM,IAAIsB,MAAM,4BlBxCnCC,EkB0CQC,EAAWjV,EAAQoT,kBACnB8B,EAAkBzB,EAAW0B,cAAcF,OAE5CC,EAAiB,MAAM,IAAIH,MAAM,6BlB7CxCC,GkB+CExF,EAAY0F,GAC2BE,SAAvCxG,ElB9CKyG,MAAMC,UAAUjO,MAAMkO,KAAKP,YkBiDzBQ,EAASC,gBAAAA,MAChBX,IACA9U,EAAU6U,EAAc7U,EAASyV,OAI/BlU,GAHF4Q,EAASrC,EAAO2D,EAAYjE,EAAWZ,EAAQ5O,EAAS2B,SAItDP,EAIE+Q,aAHFM,EAGEN,YAFFE,EAEEF,cADFK,EACEL,cAEFjU,EAKE8B,OAJFqT,EAIErT,YAHFsT,EAGEtT,iBAFFwT,EAEExT,gBADFuT,EACEvT,mBAEJwU,EAAkBjT,EAAKzD,QAAQ2V,GAC/BY,EAAW3V,IAAIwL,OAAQ,SAAUoK,GACjC7B,EAAU7C,GAAGxO,EAAWM,UACxBkN,EAAOnD,QAAQiK,GACfrD,EAAYrM,sBAER9H,EAAM,KACHsU,EAAY/D,UAAW,OAAOgG,EAAW,CAAEvW,MAAM,IACtDsU,EAAYtU,KAAK0Q,GAEfyE,GAAazE,EAAOlO,QAClB4S,GACF9K,EAASiL,EAAYH,GAEnBC,IACF5R,EAAOwS,GAAG,cAAewB,GACzBhU,EAAOwS,GAAG,YAAawB,KAGzBhU,EAAOwS,GAAG,cAAe9B,EAAYhQ,yBAEnCmR,IACFoC,IACAjU,EAAOwS,GAAG,SAAUyB,GACpBjU,EAAOwS,GAAG,YAAayB,IAEpBhB,IACHzK,YAAW,kBAAMxI,EAAOwC,KAAK,UAAS,GACtCyQ,GAAY,YAIPe,EAAoB1S,OACnBsQ,EAAkBvT,gBACd,gBAARiD,EAAuBuF,EAASiL,EAAYF,GAC3CpL,EAAYsL,EAAYF,YAGtBqC,QACCpC,EAAkBxT,gBACpB6V,EAAS3C,GAAa,GACV4C,GAAgB,GACxBrK,SAAQ,SAAAc,UAAKpE,EAAYyG,EAAOrC,GAAIiH,MAC9CqC,EAAOpK,SAAQ,SAAAc,UAAK/D,EAASoG,EAAOrC,GAAIiH,eAGjCkC,EAAgBK,EAAoB5Q,GAO3CkP,EAAW3V,IAAIqX,EAAO,SANR,eACNC,EAAapX,KAAKqX,MAAM9Q,EAAQnF,EAAQmQ,gBACxC+F,EAAgB/Q,EAAQ6Q,EAAa7Q,EAC3CsO,EAAW0C,WAAa,EACxBrR,EAASoR,MAE2B,YAG/BzB,EAAWgB,gBAAAA,UAEZW,EAAavB,EAAc,CAAE3E,WADhBmG,KAC8BZ,GACjDa,IACAd,EAASY,GACTzU,EAAOwC,KAAK,mBAGLmS,IACPnE,EAAOE,YAAYjQ,yBACnB+P,EAAOE,YAAYhQ,0BACnB8P,EAAO7Q,UAAU0Q,OACjBqC,EAAWjU,YACX+R,EAAOM,UAAU9D,QACjBwD,EAAOK,YAAY7D,MAAMC,GACzBzG,EAAYsL,EAAYzT,EAAQsT,gBAChC1E,EAAOnD,SAAQ,SAAAyD,UAAK/G,EAAY+G,EAAGlP,EAAQwT,kBAC3C7R,EAAOuS,IAAI,SAAU0B,GACrBjU,EAAOuS,IAAI,YAAa0B,GACxBjU,EAAOuS,IAAI,cAAeyB,GAC1BhU,EAAOuS,IAAI,YAAayB,YAiBjBzC,EAAa/R,gBAAAA,UACdO,EAAWyQ,EAAOhR,EAAS,SAAW,YAAY5C,MAClDuB,EAAOE,EAAQ9B,KAAO,eAAiB,mBACtCiU,EAAOe,aAAa7D,MAAM8C,EAAOlU,MAAM6B,GAAM4B,aAG7CoU,EAAgB3U,gBAAAA,UACjB0U,EAAS3C,EAAa/R,UACrBgR,EAAOnB,YAAY3Q,QAAO,SAAAkM,UAA4B,IAAvBsJ,EAAOpS,QAAQ8I,eAG9CzH,EAASK,GAChBgN,EAAO/Q,WAAWwC,iBAAiBiG,kBACnCsI,EAAOrN,SAASK,MAAMA,EAAO,YAiCtBkR,WACAlE,EAAOhN,MAAM5G,aA9KtBiX,EAAS9B,GAqMmB,CAC1B6C,gCA1CapE,EAAOhN,MAAMrG,QAAQJ,IAAI,GAC1BH,QAAU8X,KA0CtBG,gCAtCarE,EAAOhN,MAAMrG,QAAQJ,KAAK,GAC3BH,QAAU8X,KAsCtBpQ,+BAlBOkM,EAAOE,YAAYpM,gBAmB1BwQ,gCAXOjH,GAYPkH,uCAhBOvE,GAiBPyB,mBAzFKgB,IACL0B,IACA1B,GAAY,EACZzC,EAAS,GACTxQ,EAAOwC,KAAK,aAsFZ+P,MACAC,KACAwC,qCA5BOxE,EAAOX,cAAcjT,OA6B5BuV,SACA8C,0BAhEMrR,EAAO4M,EAAOhN,MAAMrG,QAAQJ,IAAI,GACtCyT,EAAO/Q,WAAWwC,iBAAiBiG,kBACnCsI,EAAOrN,SAASK,MAAMI,EAAKhH,OAAQ,IA+DnCsY,0BA3DMC,EAAO3E,EAAOhN,MAAMrG,QAAQJ,KAAK,GACvCyT,EAAO/Q,WAAWwC,iBAAiBiG,kBACnCsI,EAAOrN,SAASK,MAAM2R,EAAKvY,MAAO,IA0DlC0U,iCAxCOd,EAAOc,eAAe1U,IAAI4T,EAAOzQ,SAASnD,QAyCjDwY,iCA7CO5E,EAAOtH,YAAYvD,IAAI6K,EAAOc,eAAe1U,MA8CpDuG,WACAuR,qBACAW,6BApBOpI,GAqBPsE,eACA4C"}